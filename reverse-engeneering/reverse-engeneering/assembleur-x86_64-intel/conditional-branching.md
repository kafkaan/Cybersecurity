# Conditional Branching

***

## <mark style="color:red;">üîÄ</mark> <mark style="color:red;"></mark><mark style="color:red;">**Branchement conditionnel (Conditional Branching)**</mark>

Contrairement aux **instructions de branchement inconditionnel**, les instructions de <mark style="color:orange;">**branchement conditionnel**</mark> <mark style="color:orange;"></mark><mark style="color:orange;">ne sont ex√©cut√©es</mark> <mark style="color:orange;"></mark><mark style="color:orange;">**que lorsqu‚Äôune condition sp√©cifique est remplie**</mark>, bas√©e sur les op√©randes _**Destination**_**&#x20;et&#x20;**_**Source**_**.**

Une instruction de saut conditionnel prend plusieurs formes sous le nom de `Jcc`, o√π `cc` repr√©sente le **code de condition (Condition Code)**.

***

#### <mark style="color:green;">üìò Tableau des conditions</mark>

<table data-full-width="true"><thead><tr><th>Instruction</th><th>Condition</th><th>Description</th></tr></thead><tbody><tr><td><code>jz</code></td><td>D = 0</td><td>Destination est √©gale √† z√©ro</td></tr><tr><td><code>jnz</code></td><td>D ‚â† 0</td><td>Destination n‚Äôest pas √©gale √† z√©ro</td></tr><tr><td><code>js</code></td><td>D &#x3C; 0</td><td>Destination est n√©gative</td></tr><tr><td><code>jns</code></td><td>D ‚â• 0</td><td>Destination n‚Äôest pas n√©gative (0 ou positif)</td></tr><tr><td><code>jg</code></td><td>D > S</td><td>Destination sup√©rieure √† Source</td></tr><tr><td><code>jge</code></td><td>D ‚â• S</td><td>Destination sup√©rieure ou √©gale √† Source</td></tr><tr><td><code>jl</code></td><td>D &#x3C; S</td><td>Destination inf√©rieure √† Source</td></tr><tr><td><code>jle</code></td><td>D ‚â§ S</td><td>Destination inf√©rieure ou √©gale √† Source</td></tr></tbody></table>

***

{% hint style="warning" %}
Il existe beaucoup d‚Äôautres conditions similaires.\
Pour la liste compl√®te, voir le **manuel Intel x86\_64**, section **Jcc ‚Äì Jump if Condition is Met**.
{% endhint %}

<mark style="color:green;">**Les instructions conditionnelles ne se limitent pas aux**</mark><mark style="color:green;">**&#x20;**</mark><mark style="color:green;">**`jmp`**</mark><mark style="color:green;">**&#x20;**</mark><mark style="color:green;">**:**</mark>

* `CMOVcc` : **mov conditionnel**
* `SETcc` : **assignation conditionnelle (0 ou 1)**

***

#### <mark style="color:green;">üìå Exemples</mark>

* `cmovz rax, rbx` ‚Üí fait `mov` seulement si **ZF = 1** (i.e. √©gal √† z√©ro)
* `cmovl rax, rbx` ‚Üí fait `mov` si **r√©sultat < 0**
* `setz al` ‚Üí met `al = 1` si la condition est remplie, sinon `al = 0`

***

### <mark style="color:red;">üèÅ Registre RFLAGS</mark>

Les conditions sont v√©rifi√©es √† partir des <mark style="color:orange;">**flags du registre RFLAGS**</mark><mark style="color:orange;">.</mark>

Le registre `RFLAGS` est un **registre 64 bits**, mais il **ne stocke pas des valeurs**, il stocke **des indicateurs (flags)**.

Les **instructions arithm√©tiques** mettent √† jour ces flags.\
Par exemple :

* `dec` qui donne 0 ‚Üí met `ZF = 1`
* `sub` qui donne un r√©sultat n√©gatif ‚Üí met `SF = 1`
* `div` qui d√©passe ‚Üí met `CF = 1`

***

#### <mark style="color:green;">üìò Extrait des flags importants dans RFLAGS</mark>

<table data-full-width="true"><thead><tr><th>Bit</th><th>Nom</th><th>Signification</th></tr></thead><tbody><tr><td>0</td><td>CF</td><td>Carry Flag (d√©passement non sign√©)</td></tr><tr><td>2</td><td>PF</td><td>Parity Flag (nombre pair/impair de bits)</td></tr><tr><td>4</td><td>AF</td><td>Auxiliary Flag</td></tr><tr><td>6</td><td>ZF</td><td>Zero Flag (r√©sultat == 0)</td></tr><tr><td>7</td><td>SF</td><td>Sign Flag (r√©sultat n√©gatif)</td></tr><tr><td>11</td><td>OF</td><td>Overflow Flag (d√©passement sign√©)</td></tr></tbody></table>

Les noms `ZR` (ZF=1) et `NZ` (ZF=0) sont utilis√©s pour repr√©senter **Z√©ro** et **Non-Z√©ro**.

{% hint style="info" %}
***

Le registre **RFLAGS** (ou EFLAGS dans les architectures 32 bits) est un registre sp√©cial dans les processeurs x86/x64 qui contient des bits appel√©s **flags**. Ces bits sont mis √† jour par le processeur apr√®s certaines instructions (comme `ADD`, `SUB`, `CMP`, etc.) pour indiquer des informations sur le r√©sultat de l'op√©ration. Les flags influencent les sauts conditionnels (ex. : `JZ`, `JNZ`) et sont souvent analys√©s en reverse engineering pour comprendre la logique d'un programme.

Les flags que tu as mentionn√©s sont :

* **CF** : Carry Flag (Drapeau de retenue)
* **PF** : Parity Flag (Drapeau de parit√©)
* **AF** : Auxiliary Carry Flag (Drapeau de retenue auxiliaire)
* **ZF** : Zero Flag (Drapeau de z√©ro)
* **SF** : Sign Flag (Drapeau de signe)
* **OF** : Overflow Flag (Drapeau de d√©passement)

***

<mark style="color:green;">**1. CF (Carry Flag) - Drapeau de retenue**</mark>

**R√¥le** : Le **Carry Flag** est activ√© (mis √† 1) quand une op√©ration arithm√©tique produit une **retenue** (carry) ou un **emprunt** (borrow) dans les calculs impliquant des nombres non sign√©s. Il est souvent utilis√© pour les additions ou soustractions.

* **Quand est-il modifi√© ?** Par des instructions comme `ADD`, `SUB`, `CMP`.
* **Utilit√©** : D√©tecter si un r√©sultat d√©passe la taille du registre (ex. : additionner deux nombres trop grands pour un registre 8 bits).

**Exemple simple** : Imaginons qu'on additionne deux nombres 8 bits dans un registre (par exemple, `AL`) :

```asm
MOV AL, 0xFF  ; AL = 255 (maximum pour 8 bits)
ADD AL, 1     ; AL = AL + 1
```

* **R√©sultat** : `255 + 1 = 256`, mais un registre 8 bits ne peut contenir que 255 max. Donc, `AL` revient √† `0`, et le **CF** est mis √† **1** pour indiquer qu'il y a une retenue.
* **V√©rification** : Une instruction comme `JC` (Jump if Carry) peut √™tre utilis√©e pour sauter si `CF = 1`.

**Analogie** : C'est comme si tu comptes sur tes doigts (0 √† 9). Si tu ajoutes 9 + 1, tu d√©passes 9, donc tu remets √† 0 et tu "retiens" 1 (le carry).

***

<mark style="color:green;">**2. PF (Parity Flag) - Drapeau de parit√©**</mark>

**R√¥le** : Le **Parity Flag** indique si le nombre de bits √† **1** dans le r√©sultat d'une op√©ration est **pair** ou **impair**. Il est mis √† **1** si le nombre de bits √† 1 est pair, sinon √† **0**.

* **Quand est-il modifi√© ?** Par des instructions comme `ADD`, `SUB`, `AND`, `OR`.
* **Utilit√©** : Principalement utilis√© dans les anciens syst√®mes pour v√©rifier l'int√©grit√© des donn√©es (par exemple, dans les communications s√©rie).

**Exemple simple** :

```asm
MOV AL, 0x05  ; AL = 00000101 en binaire (3 bits √† 1)
SUB AL, 0x01  ; AL = 00000100 (4 en binaire, 2 bits √† 1)
```

* **R√©sultat** : Le r√©sultat (`0x04`) a 2 bits √† 1 (pair), donc **PF = 1**.
* Si on fait :

```asm
MOV AL, 0x07  ; AL = 00000111 (3 bits √† 1)
```

* **R√©sultat** : 3 bits √† 1 (impair), donc **PF = 0**.

**Analogie** : Imagine que tu comptes les billes dans un sac. Si tu as un nombre pair de billes, le drapeau de parit√© est "activ√©". Sinon, il est "d√©sactiv√©".

***

<mark style="color:green;">**3. AF (Auxiliary Carry Flag) - Drapeau de retenue auxiliaire**</mark>

**R√¥le** : Le **Auxiliary Carry Flag** est activ√© (mis √† 1) quand il y a une retenue ou un emprunt entre les **4 bits inf√©rieurs** (nibble inf√©rieur) et les 4 bits sup√©rieurs d‚Äôun registre 8 bits. Il est utilis√© principalement pour les calculs en **BCD** (Binary-Coded Decimal, d√©cimal cod√© en binaire).

* **Quand est-il modifi√© ?** Par des instructions comme `ADD`, `SUB`.
* **Utilit√©** : Rarement utilis√© en programmation moderne, mais important pour les syst√®mes anciens qui manipulent des nombres d√©cimaux cod√©s.

**Exemple simple** :

```asm
MOV AL, 0x09  ; AL = 9 en BCD
ADD AL, 0x01  ; AL = 9 + 1 = 10
```

* **R√©sultat** : En BCD, 9 + 1 donne `0x10` (10 en d√©cimal), mais dans les 4 bits inf√©rieurs, on passe de `1001` (9) √† `0000` avec une retenue dans les 4 bits sup√©rieurs. Donc, **AF = 1**.
* Une instruction comme `DAA` (Decimal Adjust after Addition) utilise **AF** pour ajuster le r√©sultat en BCD.

**Analogie** : Imagine que tu fais une addition sur une calculatrice √† 4 chiffres. Si tu d√©passes 9 dans un chiffre, tu portes une retenue au chiffre suivant. **AF** indique cette retenue entre les groupes de 4 bits.

***

<mark style="color:green;">**4. ZF (Zero Flag) - Drapeau de z√©ro**</mark>

**R√¥le** : Le **Zero Flag** est mis √† **1** si le r√©sultat d‚Äôune op√©ration est **z√©ro**, sinon √† **0**.

* **Quand est-il modifi√© ?** Par des instructions comme `ADD`, `SUB`, `CMP`, `AND`.
* **Utilit√©** : Tr√®s courant pour tester si deux valeurs sont √©gales (ex. : avec `CMP`) ou si un r√©sultat est nul.

**Exemple simple** :

```asm
MOV EAX, 5
SUB EAX, 5   ; EAX = 5 - 5 = 0
```

* **R√©sultat** : Le r√©sultat est `0`, donc **ZF = 1**.
* Une instruction comme `JZ` (Jump if Zero) peut sauter si **ZF = 1**.

**Exemple avec CMP** :

```asm
MOV EAX, 10
MOV EBX, 10
CMP EAX, EBX  ; Compare EAX et EBX (effectue EAX - EBX sans stocker)
```

* **R√©sultat** : `10 - 10 = 0`, donc **ZF = 1**, ce qui indique que les deux valeurs sont √©gales.

**Analogie** : C‚Äôest comme v√©rifier si ton portefeuille est vide apr√®s avoir d√©pens√© tout ton argent. Si c‚Äôest vide (z√©ro), **ZF** est activ√©.

***

<mark style="color:green;">**5. SF (Sign Flag) - Drapeau de signe**</mark>

**R√¥le** : Le **Sign Flag** refl√®te le bit de signe du r√©sultat (le bit le plus significatif). Il est mis √† **1** si le r√©sultat est **n√©gatif** (bit de signe = 1) et √† **0** si le r√©sultat est **positif** ou **z√©ro** (bit de signe = 0).

* **Quand est-il modifi√© ?** Par des instructions comme `ADD`, `SUB`, `MUL`.
* **Utilit√©** : Utilis√© pour les op√©rations sur des nombres sign√©s (entiers avec signe).

**Exemple simple** :

```asm
MOV AL, 0x80  ; AL = 10000000 en binaire (-128 en sign√©, 8 bits)
```

* **R√©sultat** : Le bit le plus significatif est `1`, donc **SF = 1** (indique un nombre n√©gatif).

**Autre exemple** :

```asm
MOV EAX, -5
ADD EAX, 2    ; EAX = -5 + 2 = -3
```

* **R√©sultat** : Le r√©sultat est n√©gatif (`-3`), donc **SF = 1**.

**Analogie** : C‚Äôest comme regarder le panneau ¬´ + ¬ª ou ¬´ - ¬ª sur un thermom√®tre. Si la temp√©rature est n√©gative, **SF** est activ√©.

***

<mark style="color:green;">**6. OF (Overflow Flag) - Drapeau de d√©passement**</mark>

**R√¥le** : Le **Overflow Flag** est activ√© (mis √† 1) quand une op√©ration sur des nombres **sign√©s** produit un r√©sultat incorrect √† cause d‚Äôun **d√©bordement** (overflow). Cela se produit quand le r√©sultat d√©passe les limites des nombres sign√©s dans le registre.

* **Quand est-il modifi√© ?** Par des instructions comme `ADD`, `SUB`.
* **Utilit√©** : D√©tecter des erreurs dans les calculs avec des nombres sign√©s.

**Exemple simple** : Imaginons un registre 8 bits (plage pour les nombres sign√©s : -128 √† +127) :

```asm
MOV AL, 0x7F  ; AL = 127 (maximum positif en 8 bits sign√©)
ADD AL, 1     ; AL = 127 + 1
```

* **R√©sultat** : `127 + 1 = 128`, mais en 8 bits sign√©, cela donne `-128` (car `0x80` est `-128` en sign√©). Le r√©sultat est incorrect, donc **OF = 1**.
* Une instruction comme `JO` (Jump if Overflow) peut sauter si **OF = 1**.

**Analogie** : Imagine que tu remplis un verre d‚Äôeau (la capacit√© du verre = 127 ml). Si tu ajoutes 1 ml de plus, le verre d√©borde, et **OF** signale ce d√©bordement.

***

<mark style="color:green;">**Exemple complet : Analyse d‚Äôun programme avec les flags**</mark>

Voici un petit programme en assembleur pour illustrer comment les flags fonctionnent ensemble :

```asm
MOV EAX, 10
MOV EBX, 15
SUB EAX, EBX  ; EAX = 10 - 15 = -5
```

Apr√®s l‚Äôinstruction `SUB`, les flags sont mis √† jour :

* **CF = 1** : Il y a un emprunt (10 < 15, donc un borrow).
* **PF** : D√©pend du nombre de bits √† 1 dans `-5` (`0xFB` = `11111011`, 7 bits √† 1, donc **PF = 0**).
* **AF** : D√©pend des 4 bits inf√©rieurs (pas de retenue ici, donc **AF = 0**).
* **ZF = 0** : Le r√©sultat n‚Äôest pas z√©ro (`-5`).
* **SF = 1** : Le r√©sultat est n√©gatif (`-5`).
* **OF = 0** : Pas de d√©bordement, car `-5` est dans la plage des nombres sign√©s.

**V√©rification** : Si le programme utilise `JS` (Jump if Sign), il sautera car **SF = 1**.

***

***
{% endhint %}

***

### <mark style="color:blue;">üß™ Exemple :</mark> <mark style="color:blue;"></mark><mark style="color:blue;">`jnz loopFib`</mark>

L‚Äôinstruction `loop` vue pr√©c√©demment est **√©quivalente √†** :

```nasm
dec rcx
jnz loopFib
```

Mais `loop` est juste une optimisation de syntaxe.

***

#### <mark style="color:green;">üìú Nouveau code avec</mark> <mark style="color:green;"></mark><mark style="color:green;">`jnz`</mark>

```nasm
global  _start

section .text
_start:
    xor rax, rax    ; initialise rax √† 0
    xor rbx, rbx    ; initialise rbx √† 0
    inc rbx         ; incr√©mente rbx √† 1
    mov rcx, 10

loopFib:
    add rax, rbx    ; calcul du nombre suivant
    xchg rax, rbx   ; √©change les valeurs
    dec rcx         ; d√©cr√©mente rcx
    jnz loopFib     ; saute si rcx ‚â† 0
```

***

#### <mark style="color:green;">üß™ Ex√©cution GDB :</mark>

```bash
$ ./assembler.sh fib.s -g
gef‚û§  b loopFib
gef‚û§  r
```

{% code fullWidth="true" %}
```gdb
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ registers ‚îÄ‚îÄ‚îÄ‚îÄ
$rax   : 0x0
$rbx   : 0x1
$rcx   : 0xa
$eflags: [zero carry parity adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]

$rax   : 0x1
$rbx   : 0x1
$rcx   : 0x9

$rax   : 0x1
$rbx   : 0x2
$rcx   : 0x8
```
{% endcode %}

***

üìå Le programme calcule toujours la **suite de Fibonacci** correctement.

√Ä chaque it√©ration :

* `rcx` est d√©cr√©ment√©
* `ZF` n‚Äôest pas activ√© tant que `rcx ‚â† 0`

Quand `rcx = 0`, alors `ZF = 1` ‚Üí `jnz` ne saute plus ‚Üí sortie de boucle.

***

### <mark style="color:red;">üß† Instruction</mark> <mark style="color:red;"></mark><mark style="color:red;">`cmp`</mark>

On peut aussi utiliser des sauts conditionnels **apr√®s un test personnalis√©**.

Exemple : on veut **arr√™ter l‚Äôex√©cution quand le Fibonacci d√©passe 10**.

***

#### <mark style="color:green;">üéØ</mark> <mark style="color:green;"></mark><mark style="color:green;">`cmp`</mark> <mark style="color:green;"></mark><mark style="color:green;">= compare (ne modifie pas les registres)</mark>

```nasm
cmp rbx, 10    ; fait rbx - 10 ‚Üí met les flags
js  loopFib    ; saute si r√©sultat < 0
```

***

#### <mark style="color:green;">üìú Nouveau code avec</mark> <mark style="color:green;"></mark><mark style="color:green;">`cmp`</mark> <mark style="color:green;"></mark><mark style="color:green;">et</mark> <mark style="color:green;"></mark><mark style="color:green;">`js`</mark>

```nasm
global  _start

section .text
_start:
    xor rax, rax    ; initialise rax √† 0
    xor rbx, rbx    ; initialise rbx √† 0
    inc rbx         ; rbx = 1

loopFib:
    add rax, rbx    ; prochain nombre
    xchg rax, rbx   ; √©change
    cmp rbx, 10     ; compare avec 10
    js loopFib      ; saute si rbx < 10
```

üîç On a supprim√© `mov rcx, 10`, car la boucle d√©pend maintenant de la valeur de `rbx`.

***

#### <mark style="color:green;">üß™ Ex√©cution GDB</mark>

```bash
$ ./assembler.sh fib.s -g
gef‚û§  b loopFib
gef‚û§  r
```

```gdb
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ registers ‚îÄ‚îÄ‚îÄ‚îÄ
$rax   : 0x1
$rbx   : 0x1
$eflags: [zero CARRY parity ADJUST SIGN ...]
‚Üí   js     0x401009 <loopFib>   TAKEN [Reason: S]
```

‚û°Ô∏è On voit que le **flag S (sign)** est activ√© ‚Üí saut pris

***

#### <mark style="color:green;">üß™ Jusqu‚Äô√† rbx > 10</mark>

On peut utiliser **breakpoint conditionnel** pour arr√™ter quand `rbx > 10`.

```gdb
gef‚û§  del 1
gef‚û§  disas loopFib
‚Üí 0x401012 : js 0x401009

gef‚û§  b *loopFib+9 if $rbx > 10
gef‚û§  c
```

```gdb
$rax   : 0x8
$rbx   : 0xd
$eflags: [zero carry PARITY adjust sign ...]
‚Üí js     0x401009   NOT taken [Reason: !(S)]
```

‚úÖ Comme `rbx = 13`, alors `rbx - 10 = 3`, donc le r√©sultat est positif ‚Üí `SIGN flag` d√©sactiv√© ‚Üí saut non pris.

***

### <mark style="color:red;">‚úÖ R√©sum√© ‚Äì Trois techniques de boucle</mark>

| M√©thode     | Code                                      | Conditions                   |
| ----------- | ----------------------------------------- | ---------------------------- |
| `loop rcx`  | `mov rcx, 10` + `loop loopFib`            | boucle 10 fois               |
| `dec + jnz` | `mov rcx, 10` + `dec rcx` + `jnz loopFib` | m√™me effet, plus contr√¥lable |
| `cmp + js`  | `cmp rbx, 10` + `js loopFib`              | saute tant que `rbx < 10`    |

***

<mark style="color:green;">üß†</mark> <mark style="color:green;"></mark><mark style="color:green;">**Note**</mark> <mark style="color:green;"></mark><mark style="color:green;">:</mark>\
`je` = `jz` (ZF=1)\
`jne` = `jnz` (ZF=0)\
`jge` = `jnl`\
‚Üí Ce sont **des alias**, utilis√©s selon le style ou la convention du langage.

***
