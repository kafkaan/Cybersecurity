# Advanced C

## <mark style="color:red;">Segmentation M√©moire</mark>

La m√©moire d'un programme compil√© est divis√©e en cinq segments :&#x20;

* Text
* Data
* Bss
* Heap
* &#x20;Stack.&#x20;

Chaque segment repr√©sente une portion sp√©ciale de la m√©moire qui est r√©serv√©e √† un certain usage.

***

### <mark style="color:blue;">Le Segment Text (Code)</mark>

Le segment text est parfois aussi appel√© **segment de code**.&#x20;

C'est l√† que se trouvent les **instructions en langage machine** assembl√© du programme.&#x20;

L'ex√©cution des instructions dans ce segment est **non lin√©aire** :motorway: gr√¢ce aux structures de contr√¥le de haut niveau et aux fonctions mentionn√©es pr√©c√©demment, qui se compilent en instructions de branchement, de saut et d'appel en langage assembleur.

Pendant l'ex√©cution d'un programme, l'EIP est d√©fini sur la premi√®re instruction du segment text. Le processeur suit ensuite une boucle d'ex√©cution qui fait ce qui suit :

1. **Lit l'instruction vers laquelle pointe EIP** :book:
2. **Ajoute la longueur en octets de l'instruction √† EIP** :heavy\_plus\_sign:
3. **Ex√©cute l'instruction qui a √©t√© lue √† l'√©tape 1** :zap:
4. **Retourne √† l'√©tape 1** :airplane\_departure:

Parfois l'instruction sera un saut ou un appel, ce qui change l'EIP vers une adresse diff√©rente de la m√©moire.&#x20;

Le processeur ne se soucie pas du changement, car il s'attend de toute fa√ßon √† ce que l'ex√©cution soit non lin√©aire. Si EIP est modifi√© √† l'√©tape 3, le processeur retournera simplement √† l'√©tape 1 et lira l'instruction trouv√©e √† l'adresse de ce que EIP a √©t√© chang√©.

{% hint style="danger" %}
L'autorisation d'√©criture est d√©sactiv√©e dans le segment text, car il n'est pas utilis√© pour stocker des variables, seulement du code.&#x20;
{% endhint %}

Cela emp√™che les gens de modifier r√©ellement le code du programme ; toute tentative d'√©criture dans ce segment de m√©moire fera que le programme alertera l'utilisateur que quelque chose de grave s'est produit, et le programme sera tu√©.&#x20;

‚áí Un autre avantage de ce segment √©tant en lecture seule est qu'il peut √™tre partag√© entre diff√©rentes copies du programme, permettant plusieurs ex√©cutions du programme en m√™me temps sans aucun probl√®me.&#x20;

‚áí Il faut √©galement noter que ce segment de m√©moire a une taille fixe, puisque rien n'y change jamais.

***

### <mark style="color:blue;">Les Segments Data et BSS</mark>

Les segments data et bss sont utilis√©s pour stocker les variables globales et statiques du programme.&#x20;

‚áí Le segment data est rempli avec les variables globales et statiques initialis√©es,

‚áí Le segment bss est rempli avec leurs homologues non initialis√©es.&#x20;

Bien que ces segments soient modifiables, ils ont √©galement une taille fixe. Rappelez-vous que les variables globales persistent, malgr√© le contexte fonctionnel (comme la variable j dans les exemples pr√©c√©dents).&#x20;

‚áí Les variables globales et statiques peuvent persister parce qu'elles sont stock√©es dans leurs propres segments de m√©moire.

{% hint style="success" %}
üí° En r√©sum√© : **¬´ taille fixe ¬ª** signifie que la quantit√© de m√©moire r√©serv√©e pour ces variables ne change pas pendant l‚Äôex√©cution, contrairement √† la m√©moire dynamique (heap), qui peut cro√Ætre ou d√©cro√Ætre avec `malloc`/`free`.
{% endhint %}

***

### <mark style="color:blue;">Le Segment Heap (Tas)</mark>

‚áí Le segment heap est un segment de m√©moire qu'un programmeur peut contr√¥ler directement.&#x20;

Des blocs de m√©moire dans ce segment peuvent √™tre allou√©s et utilis√©s pour tout ce dont le programmeur pourrait avoir besoin. Un point notable concernant le segment heap est qu'il n'a pas de taille fixe, donc il peut grandir ou r√©tr√©cir selon les besoins.

&#x20;Toute la m√©moire dans le heap est g√©r√©e par des algorithmes d'allocation et de d√©sallocation, qui respectivement r√©servent une r√©gion de m√©moire dans le heap pour utilisation et suppriment les r√©servations pour permettre √† cette portion de m√©moire d'√™tre r√©utilis√©e pour des r√©servations ult√©rieures.&#x20;

‚áí Le heap grandira et r√©tr√©cira selon la quantit√© de m√©moire r√©serv√©e pour utilisation.&#x20;

Cela signifie qu'un programmeur utilisant les fonctions d'allocation du heap peut r√©server et lib√©rer de la m√©moire √† la vol√©e. La croissance du heap se d√©place vers le bas vers des adresses m√©moire plus √©lev√©es.

***

### <mark style="color:blue;">Le Segment Stack (Pile)</mark>

‚áí Le segment stack a √©galement une taille variable et est utilis√© comme un bloc-notes temporaire pour stocker les variables de fonction locales et le contexte pendant les appels de fonction.&#x20;

C'est ce que regarde la commande backtrace de GDB.&#x20;

* Quand un programme appelle une fonction, cette fonction aura son propre ensemble de variables pass√©es, et le code de la fonction sera √† un emplacement m√©moire diff√©rent dans le segment text (ou code).&#x20;
* Puisque le contexte et l'EIP doivent changer quand une fonction est appel√©e, la pile est utilis√©e pour se souvenir de toutes les variables pass√©es, de l'emplacement o√π l'EIP devrait retourner apr√®s que la fonction soit termin√©e, et de toutes les variables locales utilis√©es par cette fonction. Toutes ces informations sont stock√©es ensemble sur la pile dans ce qu'on appelle collectivement un frame de pile. La pile contient de nombreux frames de pile.

{% hint style="warning" %}
En termes g√©n√©raux d'informatique, une pile est une structure de donn√©es abstraite qui est utilis√©e fr√©quemment. Elle a un ordre premier entr√©, dernier sorti (FILO), ce qui signifie que le premier √©l√©ment qui est mis dans une pile est le dernier √©l√©ment √† en sortir. Pensez-y comme √† enfiler des perles sur un morceau de ficelle qui a un n≈ìud √† une extr√©mit√© - vous ne pouvez pas enlever la premi√®re perle jusqu'√† ce que vous ayez retir√© toutes les autres perles. Quand un √©l√©ment est plac√© dans une pile, c'est connu sous le nom de "push", et quand un √©l√©ment est retir√© d'une pile, c'est appel√© "pop".
{% endhint %}

Comme le nom l'implique, le segment stack de la m√©moire est, en fait, une structure de donn√©es de pile, qui contient des frames de pile.&#x20;

‚áí Le registre ESP est utilis√© pour garder trace de l'adresse de la fin de la pile, qui change constamment alors que des √©l√©ments sont pouss√©s dans et sortis de celle-ci.&#x20;

Puisque c'est un comportement tr√®s dynamique, il est logique que la pile ne soit pas non plus de taille fixe. Contrairement √† la croissance dynamique du heap, alors que la pile change de taille, elle grandit vers le haut dans une liste visuelle de la m√©moire, vers des adresses m√©moire plus basses.

***

### <mark style="color:blue;">Fonctionnement des Frames de Pile</mark>

La nature FILO d'une pile peut sembler √©trange, mais puisque la pile est utilis√©e pour stocker le contexte, elle est tr√®s utile. Quand une fonction est appel√©e, plusieurs choses sont pouss√©es sur la pile ensemble dans un frame de pile.&#x20;

Le registre EBP - parfois appel√© le pointeur de frame (FP) ou pointeur de base locale (LB) - est utilis√© pour r√©f√©rencer les variables de fonction locales dans le frame de pile actuel.&#x20;

Chaque frame de pile contient&#x20;

* Les param√®tres de la fonction
* Ses variables locales
* deux pointeurs qui sont n√©cessaires pour remettre les choses comme elles √©taient : le pointeur de frame sauvegard√© (SFP) et l'adresse de retour.&#x20;
* Le SFP est utilis√© pour restaurer EBP √† sa valeur pr√©c√©dente, et l'adresse de retour est utilis√©e pour restaurer EIP √† la prochaine instruction trouv√©e apr√®s l'appel de fonction. Cela restaure le contexte fonctionnel du frame de pile pr√©c√©dent.

<mark style="color:green;">**Exemple Pratique : stack\_example.c**</mark>

Le code stack\_example.c suivant a deux fonctions : main() et test\_function().

```c
void test_function(int a, int b, int c, int d) {
    int flag;
    char buffer[10];
    
    flag = 31337;
    buffer[0] = 'A';
}

int main() {
    test_function(1, 2, 3, 4);
}
```

Ce programme d√©clare d'abord&#x20;

* une fonction de test qui a quatre arguments, qui sont tous d√©clar√©s comme des entiers : a, b, c, et d.&#x20;
*   Les variables locales pour la fonction incluent&#x20;

    * un entier de 4 octets appel√© flag&#x20;
    * un tampon de 10 caract√®res appel√© buffer.&#x20;

    La m√©moire pour ces variables est dans le segment stack, tandis que les instructions machine pour le code de la fonction sont stock√©es dans le segment text.

<mark style="color:green;">**Analyse avec GDB**</mark>

Apr√®s compilation du programme, son fonctionnement interne peut √™tre examin√© avec GDB.&#x20;

La sortie suivante montre les instructions machine d√©sassembl√©es pour main() et test\_function(). La fonction main() commence √† 0x08048357 et test\_function() commence √† 0x08048344.&#x20;

Les premi√®res instructions de chaque fonction (montr√©es en gras ci-dessous) configurent le frame de pile. Ces instructions sont collectivement appel√©es <mark style="color:$warning;">**le prologue de proc√©dure**</mark> ou prologue de fonction.&#x20;

Elles sauvegardent le pointeur de frame sur la pile, et elles sauvent la m√©moire de pile pour les variables de fonction locales.&#x20;

Parfois le prologue de fonction g√©rera aussi un alignement de pile. Les instructions exactes du prologue varieront grandement selon le compilateur et les options du compilateur, mais en g√©n√©ral ces instructions construisent le frame de pile.

{% code fullWidth="true" %}
```nasm
reader@hacking:~/booksrc $ gcc -g stack_example.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) disass main
Dump of assembler code for function main():
0x08048357 <main+0>:    push   ebp
0x08048358 <main+1>:    mov    ebp,esp
0x0804835a <main+3>:    sub    esp,0x18
0x0804835d <main+6>:    and    esp,0xfffffff0
0x08048360 <main+9>:    mov    eax,0x0
0x08048365 <main+14>:   sub    esp,eax
0x08048367 <main+16>:   mov    DWORD PTR [esp+12],0x4
0x0804836f <main+24>:   mov    DWORD PTR [esp+8],0x3
0x08048377 <main+32>:   mov    DWORD PTR [esp+4],0x2
0x0804837f <main+40>:   mov    DWORD PTR [esp],0x1
0x08048386 <main+47>:   call   0x8048344 <test_function>
0x0804838b <main+52>:   leave  
0x0804838c <main+53>:   ret    
End of assembler dump

(gdb) disass test_function
Dump of assembler code for function test_function:
0x08048344 <test_function+0>:   push   ebp
0x08048345 <test_function+1>:   mov    ebp,esp
0x08048347 <test_function+3>:   sub    esp,0x28
0x0804834a <test_function+6>:   mov    DWORD PTR [ebp-12],0x7a69
0x08048351 <test_function+13>:  mov    BYTE PTR [ebp-40],0x41
0x08048355 <test_function+17>:  leave  
0x08048356 <test_function+18>:  ret    
End of assembler dump
```
{% endcode %}

***

### <mark style="color:blue;">Construction du Frame de Pile</mark>

Quand le programme est ex√©cut√©, la fonction main() est appel√©e, qui appelle simplement test\_function().

Quand test\_function() est appel√©e depuis la fonction main(), **les diverses valeurs sont pouss√©es sur la pile pour cr√©er le d√©but du frame de pile**

Quand test\_function() est appel√©e, les arguments de la fonction sont pouss√©s sur la pile dans l'ordre inverse (puisque c'est FILO). Les arguments pour la fonction sont 1, 2, 3, et 4, donc les instructions push subs√©quentes poussent 4, 3, 2, et finalement 1 sur la pile. Ces valeurs correspondent aux variables d, c, b, et a dans la fonction. Les instructions qui mettent ces valeurs sur la pile sont montr√©es en gras dans le d√©sassemblage de la fonction main() ci-dessus.

Ensuite, quand l'instruction d'assemblage call est ex√©cut√©e, **l'adresse de retour est pouss√©e sur la pile** et le flux d'ex√©cution saute au d√©but de test\_function() √† 0x08048344. La valeur de l'adresse de retour sera l'emplacement de l'instruction suivant l'EIP actuel - sp√©cifiquement, la valeur stock√©e pendant l'√©tape 3 de la boucle d'ex√©cution mentionn√©e pr√©c√©demment. Dans ce cas, l'adresse de retour pointerait vers l'instruction leave dans main() √† 0x0804838b.

L'instruction call stocke √† la fois l'adresse de retour sur la pile et fait sauter l'EIP au d√©but de test\_function(), donc les instructions du prologue de proc√©dure de test\_function() finissent de construire le frame de pile.&#x20;

Dans cette √©tape, la valeur actuelle d'EBP est pouss√©e sur la pile. Cette valeur est appel√©e le pointeur de frame sauvegard√© (SFP) et est utilis√©e plus tard pour restaurer EBP √† son √©tat original. La valeur actuelle d'ESP est ensuite copi√©e dans EBP pour d√©finir le nouveau pointeur de frame. Ce pointeur de frame est utilis√© pour r√©f√©rencer les variables locales de la fonction (flag et buffer). La m√©moire est sauv√©e pour ces variables en soustrayant d'ESP.

<mark style="color:green;">**Structure Finale du Frame de Pile**</mark>

√Ä la fin, le frame de pile ressemble √† quelque chose comme ceci

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-23 11-02-42.png" alt=""><figcaption></figcaption></figure>

<mark style="color:green;">**Observation avec GDB**</mark>

Nous pouvons observer la construction du frame de pile sur la pile en utilisant GDB. Dans la sortie suivante, un point d'arr√™t est d√©fini dans main() avant l'appel √† test\_function() et aussi au d√©but de test\_function(). GDB mettra le premier point d'arr√™t avant que les arguments de fonction soient pouss√©s sur la pile, et le second point d'arr√™t apr√®s le prologue de proc√©dure de test\_function(). Quand le programme est ex√©cut√©, l'ex√©cution s'arr√™te au point d'arr√™t, o√π les registres ESP (pointeur de pile), EBP (pointeur de frame), et EIP (pointeur d'ex√©cution) sont examin√©s.

{% code fullWidth="true" %}
```nasm
(gdb) list main
4
5    flag = 31337;
6    buffer[0] = 'A';
7 }
8
9 int main() {
10    test_function(1, 2, 3, 4);
11 }
(gdb) break 10
Breakpoint 1 at 0x8048367: file stack_example.c, line 10.
(gdb) break test_function
Breakpoint 2 at 0x804834a: file stack_example.c, line 5.
(gdb) run
Starting program: /home/reader/booksrc/a.out

Breakpoint 1, main () at stack_example.c:10
10        test_function(1, 2, 3, 4);
(gdb) i r esp ebp eip
esp            0xbffff7f0       0xbffff7f0
ebp            0xbffff808       0xbffff808
eip            0x8048367        0x8048367 <main+16>
(gdb) x/5i $eip
0x8048367 <main+16>:    mov    DWORD PTR [esp+12],0x4
0x804836f <main+24>:    mov    DWORD PTR [esp+8],0x3
0x8048377 <main+32>:    mov    DWORD PTR [esp+4],0x2
0x804837f <main+40>:    mov    DWORD PTR [esp],0x1
0x8048386 <main+47>:    call   0x8048344 <test_function>
```
{% endcode %}

Ce point d'arr√™t est juste avant que le frame de pile pour l'appel test\_function() soit cr√©√©. Cela signifie que le bas de ce nouveau frame de pile est √† la valeur actuelle d'ESP, 0xbffff7f0. Le prochain point d'arr√™t est juste apr√®s le prologue de proc√©dure pour test\_function(), donc continuer construira le frame de pile. La sortie ci-dessous montre des informations similaires au second point d'arr√™t. Les variables locales (flag et buffer) sont r√©f√©renc√©es relativement au pointeur de frame (EBP).

{% code fullWidth="true" %}
```
(gdb) cont
Continuing.

Breakpoint 2, test_function (a=1, b=2, c=3, d=4) at stack_example.c:5
5        flag = 31337;
(gdb) i r esp ebp eip
esp            0xbffff7c0       0xbffff7c0
ebp            0xbffff7e8       0xbffff7e8
eip            0x804834a        0x804834a <test_function+6>
(gdb) disass test_function
Dump of assembler code for function test_function:
0x08048344 <test_function+0>:   push   ebp
0x08048345 <test_function+1>:   mov    ebp,esp
0x08048347 <test_function+3>:   sub    esp,0x28
0x0804834a <test_function+6>:   mov    DWORD PTR [ebp-12],0x7a69
0x08048351 <test_function+13>:  mov    BYTE PTR [ebp-40],0x41
0x08048355 <test_function+17>:  leave  
0x08048356 <test_function+18>:  ret    
End of assembler dump.
(gdb) print $ebp-12
$1 = (void *) 0xbffff7dc
(gdb) print $ebp-40
$2 = (void *) 0xbffff7c0
(gdb) x/16xw $esp
0xbffff7c0: 0x00000000      0x08049548      0xbffff7d8      0x08048249
0xbffff7d0: 0xb7f9f729      0xb7fd6ff4      0xbffff808      0x080483b9
0xbffff7e0: 0xb7fd6ff4      0xbffff89c      0xbffff808      0x0804838b
0xbffff7f0: 0x00000001      0x00000002      0x00000003      0x00000004
```
{% endcode %}

Le frame de pile est montr√© sur la pile √† la fin. Les quatre arguments √† la fonction peuvent √™tre vus au bas du frame de pile (‚ë†), avec l'adresse de retour trouv√©e directement au-dessus (‚ë°). Au-dessus de cela se trouve le pointeur de frame sauvegard√© de 0xbffff808 (‚ë¢), qui est ce qu'√©tait EBP dans le frame de pile pr√©c√©dent. Le reste de la m√©moire est sauv√© pour les variables de pile locales : flag et buffer. Calculer leurs adresses relatives √† EBP montre leurs emplacements exacts dans le frame de pile. La m√©moire pour la variable flag est montr√©e √† (‚ë£) et la m√©moire pour la variable buffer est montr√©e √† (‚ë§). L'espace suppl√©mentaire dans le frame de pile est juste du remplissage.

***

### <mark style="color:blue;">Fin d'Ex√©cution et Nettoyage</mark>

Apr√®s que l'ex√©cution se termine, l'entier frame de pile est sorti de la pile, et l'EIP est d√©fini √† l'adresse de retour pour que le programme puisse continuer l'ex√©cution. Si une autre fonction √©tait appel√©e dans la fonction, un autre frame de pile serait pouss√© sur la pile, et ainsi de suite. Comme chaque fonction se termine, son frame de pile est sorti de la pile pour que l'ex√©cution puisse √™tre retourn√©e √† la fonction pr√©c√©dente. Ce comportement est la raison pour laquelle ce segment de m√©moire est organis√© dans une structure de donn√©es FILO.

***

<figure><img src="../../../.gitbook/assets/Screenshot from 2025-09-23 14-36-47.png" alt=""><figcaption></figcaption></figure>

***

```
Adresses basses
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Segment de texte      ‚îÇ  ‚Üê Code compil√©
‚îÇ     (code)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Segment de donn√©es    ‚îÇ  ‚Üê Variables initialis√©es
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Segment bss           ‚îÇ  ‚Üê Variables non initialis√©es
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Segment de tas        ‚îÇ  ‚Üì Grandit vers les adresses
‚îÇ     (heap)              ‚îÇ    plus hautes
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                         ‚îÇ
‚îÇ   Espace libre          ‚îÇ
‚îÇ                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Segment de pile       ‚îÇ  ‚Üë Grandit vers les adresses
‚îÇ     (stack)             ‚îÇ    plus basses
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
Adresses hautes0x271 Segments de M√©moire en CEn C, comme dans d'autres langages compil√©s, le code compil√© va dans le segment de texte, tandis que les variables r√©sident dans les segments restants. Le segment de m√©moire exact dans lequel une variable sera stock√©e d√©pend de la fa√ßon dont la variable est d√©finie.
```

***

## <mark style="color:red;">Using the Heap</mark>

Utiliser les autres segments de m√©moire est simplement une question de la fa√ßon dont vous d√©clarez les variables. Cependant, utiliser le tas n√©cessite un peu plus d'effort. Comme d√©montr√© pr√©c√©demment, allouer de la m√©moire sur le tas se fait en utilisant la fonction `malloc()`. Cette fonction accepte une taille comme seul argument et r√©serve cette quantit√© d'espace dans le segment de tas, retournant l'adresse du d√©but de cette m√©moire comme un pointeur void.

**Important :** Si la fonction `malloc()` ne peut pas allouer de m√©moire pour une raison quelconque, elle retournera simplement un pointeur NULL avec une valeur de 0.

La fonction de d√©sallocation correspondante est `free()`. Cette fonction accepte un pointeur comme seul argument et lib√®re cet espace m√©moire sur le tas afin qu'il puisse √™tre utilis√© √† nouveau plus tard.

<mark style="color:green;">**Exemple Pratique : heap\_example.c**</mark>

{% code fullWidth="true" %}
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[]) {
    char *char_ptr;    // Un pointeur de caract√®re
    int *int_ptr;      // Un pointeur d'entier
    int mem_size;
    
    if (argc < 2)      // S'il n'y a pas d'arguments en ligne de commande,
        mem_size = 50; // utilise 50 comme valeur par d√©faut.
    else
        mem_size = atoi(argv[1]);
    
    printf("\t[+] allocation de %d octets de m√©moire sur le tas pour char_ptr\n", mem_size);
    char_ptr = (char *) malloc(mem_size); // Allocation de m√©moire sur le tas
    
    if(char_ptr == NULL) { // V√©rification d'erreur, au cas o√π malloc() √©choue
        fprintf(stderr, "Erreur: impossible d'allouer de la m√©moire sur le tas.\n");
        exit(-1);
    }
    
    strcpy(char_ptr, "Cette m√©moire est situ√©e sur le tas.");
    printf("char_ptr (%p) --> '%s'\n", char_ptr, char_ptr);
    
    printf("\t[+] allocation de 12 octets de m√©moire sur le tas pour int_ptr\n");
    int_ptr = (int *) malloc(12); // Allocation de m√©moire sur le tas √† nouveau
    
    if(int_ptr == NULL) { // V√©rification d'erreur, au cas o√π malloc() √©choue
        fprintf(stderr, "Erreur: impossible d'allouer de la m√©moire sur le tas.\n");
        exit(-1);
    }
    
    *int_ptr = 31337; // Place la valeur 31337 l√† o√π int_ptr pointe.
    printf("int_ptr (%p) --> %d\n", int_ptr, *int_ptr);
    
    printf("\t[-] lib√©ration de la m√©moire du tas de char_ptr...\n");
    free(char_ptr); // Lib√©ration de la m√©moire du tas
    
    printf("\t[+] allocation de 15 autres octets pour char_ptr\n");
    char_ptr = (char *) malloc(15); // Allocation de plus de m√©moire sur le tas
    
    if(char_ptr == NULL) { // V√©rification d'erreur, au cas o√π malloc() √©choue
        fprintf(stderr, "Erreur: impossible d'allouer de la m√©moire sur le tas.\n");
        exit(-1);
    }
    
    strcpy(char_ptr, "nouvelle m√©moire");
    printf("char_ptr (%p) --> '%s'\n", char_ptr, char_ptr);
    
    printf("\t[-] lib√©ration de la m√©moire du tas de int_ptr...\n");
    free(int_ptr); // Lib√©ration de la m√©moire du tas
    
    printf("\t[-] lib√©ration de la m√©moire du tas de char_ptr...\n");
    free(char_ptr); // Lib√©ration de l'autre bloc de m√©moire du tas
}
```
{% endcode %}

#### <mark style="color:green;">Explication du Programme</mark>

Ce programme accepte un argument de ligne de commande pour la taille de la premi√®re allocation m√©moire, avec une valeur par d√©faut de 50. Ensuite, il utilise les fonctions `malloc()` et `free()` pour allouer et d√©sallouer de la m√©moire sur le tas. Il y a de nombreuses d√©clarations `printf()` pour d√©boguer ce qui se passe r√©ellement quand le programme est ex√©cut√©.

**Points cl√©s :**

* Puisque `malloc()` ne sait pas quel type de m√©moire elle alloue, elle retourne un pointeur void vers la m√©moire de tas nouvellement allou√©e, qui doit √™tre converti dans le type appropri√©
* Apr√®s chaque appel `malloc()`, il y a un bloc de v√©rification d'erreur qui v√©rifie si l'allocation a √©chou√© ou non
* Si l'allocation √©choue et que le pointeur est NULL, `fprintf()` est utilis√©e pour imprimer un message d'erreur vers l'erreur standard et le programme se termine
* La fonction `fprintf()` est tr√®s similaire √† `printf()` ; cependant, son premier argument est `stderr`, qui est un flux de fichier standard destin√© √† afficher les erreurs

#### <mark style="color:green;">**R√©sultats d'Ex√©cution**</mark>

#### Ex√©cution avec la valeur par d√©faut (50 octets)

```bash
$ gcc -o heap_example heap_example.c
$ ./heap_example
[+] allocation de 50 octets de m√©moire sur le tas pour char_ptr
char_ptr (0x804a008) --> 'Cette m√©moire est situ√©e sur le tas.'
[+] allocation de 12 octets de m√©moire sur le tas pour int_ptr
int_ptr (0x804a040) --> 31337
[-] lib√©ration de la m√©moire du tas de char_ptr...
[+] allocation de 15 autres octets pour char_ptr
char_ptr (0x804a050) --> 'nouvelle m√©moire'
[-] lib√©ration de la m√©moire du tas de int_ptr...
[-] lib√©ration de la m√©moire du tas de char_ptr...
```

#### Ex√©cution avec 100 octets

```bash
$ ./heap_example 100
[+] allocation de 100 octets de m√©moire sur le tas pour char_ptr
char_ptr (0x804a008) --> 'Cette m√©moire est situ√©e sur le tas.'
[+] allocation de 12 octets de m√©moire sur le tas pour int_ptr
int_ptr (0x804a070) --> 31337
[-] lib√©ration de la m√©moire du tas de char_ptr...
[+] allocation de 15 autres octets pour char_ptr
char_ptr (0x804a008) --> 'nouvelle m√©moire'
[-] lib√©ration de la m√©moire du tas de int_ptr...
[-] lib√©ration de la m√©moire du tas de char_ptr...
```

<mark style="color:green;">**Analyse du Comportement du Tas**</mark>

#### <mark style="color:orange;">Comportement avec Allocation de 50 octets</mark>

Dans la premi√®re sortie, remarquez que chaque bloc de m√©moire a une adresse m√©moire progressivement plus √©lev√©e dans le tas. M√™me si les premiers 50 octets ont √©t√© d√©sallou√©s, quand 15 octets de plus sont demand√©s, ils sont plac√©s apr√®s les 12 octets allou√©s pour `int_ptr`.

#### <mark style="color:orange;">Comportement avec Allocation de 100 octets</mark>

Si un bloc de m√©moire plus grand est allou√© puis d√©sallou√©, l'allocation finale de 15 octets se produira dans cet espace m√©moire lib√©r√©, √† la place. Cela d√©montre comment le gestionnaire de tas r√©utilise l'espace lib√©r√© quand c'est appropri√©.

**Observations importantes :**

* Les fonctions d'allocation de tas contr√¥lent ce comportement
* En exp√©rimentant avec diff√©rentes valeurs, vous pouvez d√©terminer exactement quand la fonction d'allocation choisit de r√©cup√©rer l'espace lib√©r√© pour de nouvelles allocations
* Souvent, de simples d√©clarations `printf()` informatives et un peu d'exp√©rimentation peuvent r√©v√©ler beaucoup de choses sur le syst√®me sous-jacent

#### <mark style="color:green;">Principe de R√©utilisation de la M√©moire</mark>

Le gestionnaire de m√©moire du tas essaie d'optimiser l'utilisation de l'espace en :

1. **Allouant s√©quentiellement** quand il n'y a pas d'espace lib√©r√© disponible
2. **R√©utilisant l'espace lib√©r√©** quand la taille demand√©e peut s'adapter dans un bloc pr√©c√©demment lib√©r√©
3. **Maintenant une efficacit√©** en √©vitant la fragmentation excessive de la m√©moire

***

{% code fullWidth="true" %}
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void *errorchecked_malloc(unsigned int); // Prototype de fonction pour errorchecked_malloc()

int main(int argc, char *argv[]) {
    char *char_ptr;    // Un pointeur de caract√®re
    int *int_ptr;      // Un pointeur d'entier
    int mem_size;
    
    if (argc < 2)      // S'il n'y a pas d'arguments en ligne de commande,
        mem_size = 50; // utilise 50 comme valeur par d√©faut.
    else
        mem_size = atoi(argv[1]);
    
    printf("\t[+] allocation de %d octets de m√©moire sur le tas pour char_ptr\n", mem_size);
    char_ptr = (char *) errorchecked_malloc(mem_size); // Allocation de m√©moire sur le tas
    
    strcpy(char_ptr, "Cette m√©moire est situ√©e sur le tas.");
    printf("char_ptr (%p) --> '%s'\n", char_ptr, char_ptr);
    
    printf("\t[+] allocation de 12 octets de m√©moire sur le tas pour int_ptr\n");
    int_ptr = (int *) errorchecked_malloc(12); // Allocation de m√©moire sur le tas √† nouveau
    
    *int_ptr = 31337; // Place la valeur 31337 l√† o√π int_ptr pointe.
    printf("int_ptr (%p) --> %d\n", int_ptr, *int_ptr);
    
    printf("\t[-] lib√©ration de la m√©moire du tas de char_ptr...\n");
    free(char_ptr); // Lib√©ration de la m√©moire du tas
    
    printf("\t[+] allocation de 15 autres octets pour char_ptr\n");
    char_ptr = (char *) errorchecked_malloc(15); // Allocation de plus de m√©moire sur le tas
    
    strcpy(char_ptr, "nouvelle m√©moire");
    printf("char_ptr (%p) --> '%s'\n", char_ptr, char_ptr);
    
    printf("\t[-] lib√©ration de la m√©moire du tas de int_ptr...\n");
    free(int_ptr); // Lib√©ration de la m√©moire du tas
    
    printf("\t[-] lib√©ration de la m√©moire du tas de char_ptr...\n");
    free(char_ptr); // Lib√©ration de l'autre bloc de m√©moire du tas
}

void *errorchecked_malloc(unsigned int size) { // Une fonction malloc() avec v√©rification d'erreur
    void *ptr;
    ptr = malloc(size);
    if(ptr == NULL) {
        fprintf(stderr, "Erreur: impossible d'allouer de la m√©moire sur le tas.\n");
        exit(-1);
    }
    return ptr;
}
```
{% endcode %}

***

## <mark style="color:red;">Acc√®s aux Fichiers en C</mark>

Il y a deux fa√ßons principales d'acc√©der aux fichiers en C : les descripteurs de fichiers et les flux de fichiers (filestreams).&#x20;

Les descripteurs de fichiers utilisent un ensemble de fonctions d'E/S de bas niveau, et les flux de fichiers sont une forme de niveau sup√©rieur d'E/S mise en m√©moire tampon qui est construite sur les fonctions de niveau inf√©rieur.

### <mark style="color:blue;">Concept des Descripteurs de Fichiers</mark>

Le code-barres au dos de ce livre repr√©sente un num√©ro. Parce que ce num√©ro est unique parmi les autres livres dans une librairie, le caissier peut scanner le num√©ro √† la caisse et l'utiliser pour r√©f√©rencer des informations sur ce livre dans la base de donn√©es du magasin. De m√™me, un descripteur de fichier est un num√©ro qui est utilis√© pour r√©f√©rencer des fichiers ouverts.

### <mark style="color:blue;">Fonctions Principales</mark>

Quatre fonctions communes qui utilisent les descripteurs de fichiers sont `open()`, `close()`, `read()`, et `write()`. Toutes ces fonctions retourneront -1 s'il y a une erreur.

* **`open()`** : ouvre un fichier pour lecture et/ou √©criture et retourne un descripteur de fichier
* **Le descripteur de fichier retourn√©** : juste une valeur enti√®re, mais elle est unique parmi les fichiers ouverts
* **Le descripteur de fichier** : pass√© comme argument aux autres fonctions comme un pointeur vers le fichier ouvert

#### <mark style="color:green;">Arguments des Fonctions</mark>

* **`close()`** : le descripteur de fichier est le seul argument
* **`read()` et `write()`** : les arguments sont le descripteur de fichier, un pointeur vers les donn√©es √† lire ou √©crire, et le nombre d'octets √† lire ou √©crire depuis cet emplacement
* **`open()`** : les arguments sont un pointeur vers le nom de fichier √† ouvrir et une s√©rie de drapeaux pr√©d√©finis qui sp√©cifient le mode d'acc√®s

### <mark style="color:blue;">Exemple Pratique : simplenote.c</mark>

{% code fullWidth="true" %}
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>

void usage(char *prog_name, char *filename) {
    printf("Usage: %s <donn√©es √† ajouter √† %s>\n", prog_name, filename);
    exit(0);
}

void fatal(char *); // Une fonction pour les erreurs fatales
void *ec_malloc(unsigned int); // Un wrapper malloc() avec v√©rification d'erreur

int main(int argc, char *argv[]) {
    int fd; // descripteur de fichier
    char *buffer, *datafile;
    
    buffer = (char *) ec_malloc(100);
    datafile = (char *) ec_malloc(20);
    strcpy(datafile, "/tmp/notes");
    
    if(argc < 2) // S'il n'y a pas d'arguments de ligne de commande,
        usage(argv[0], datafile); // affiche le message d'usage et sort.
    
    strcpy(buffer, argv[1]); // Copie dans le buffer.
    printf("[DEBUG] buffer @ %p: '%s'\n", buffer, buffer);
    printf("[DEBUG] datafile @ %p: '%s'\n", datafile, datafile);
    
    strncat(buffer, "\n", 1); // Ajoute une nouvelle ligne √† la fin.
    
    // Ouverture du fichier
    fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);
    if(fd == -1)
        fatal("dans main() lors de l'ouverture du fichier");
    printf("[DEBUG] le descripteur de fichier est %d\n", fd);
    
    // √âcriture des donn√©es
    if(write(fd, buffer, strlen(buffer)) == -1)
        fatal("dans main() lors de l'√©criture du buffer dans le fichier");
    
    // Fermeture du fichier
    if(close(fd) == -1)
        fatal("dans main() lors de la fermeture du fichier");
    
    printf("La note a √©t√© sauvegard√©e.\n");
    free(buffer);
    free(datafile);
}

// Une fonction pour afficher un message d'erreur puis sortir
void fatal(char *message) {
    char error_message[100];
    strcpy(error_message, "[!!] Erreur Fatale ");
    strncat(error_message, message, 83);
    perror(error_message);
    exit(-1);
}

// Une fonction wrapper malloc() avec v√©rification d'erreur
void *ec_malloc(unsigned int size) {
    void *ptr;
    ptr = malloc(size);
    if(ptr == NULL)
        fatal("dans ec_malloc() lors de l'allocation m√©moire");
    return ptr;
}
```
{% endcode %}

√Ä part les drapeaux d'apparence √©trange utilis√©s dans la fonction `open()`, la plupart de ce code devrait √™tre lisible. Il y a aussi quelques fonctions standard que nous n'avons pas utilis√©es auparavant :

* **`strlen()`** : accepte une cha√Æne et retourne sa longueur. Elle est utilis√©e en combinaison avec la fonction `write()`, puisqu'elle a besoin de savoir combien d'octets √©crire.
* **`perror()`** : raccourci pour "print error" et est utilis√©e dans `fatal()` pour imprimer un message d'erreur suppl√©mentaire (s'il existe) avant de sortir.

```bash
$ gcc -o simplenote simplenote.c
$ ./simplenote
Usage: ./simplenote <donn√©es √† ajouter √† /tmp/notes>

$ ./simplenote "ceci est une note de test"
[DEBUG] buffer @ 0x804a008: 'ceci est une note de test'
[DEBUG] datafile @ 0x804a070: '/tmp/notes'
[DEBUG] le descripteur de fichier est 3
La note a √©t√© sauvegard√©e.

$ cat /tmp/notes
ceci est une note de test

$ ./simplenote "super, √ßa marche"
[DEBUG] buffer @ 0x804a008: 'super, √ßa marche'
[DEBUG] datafile @ 0x804a070: '/tmp/notes'
[DEBUG] le descripteur de fichier est 3
La note a √©t√© sauvegard√©e.

$ cat /tmp/notes
ceci est une note de test
super, √ßa marche
```

### <mark style="color:blue;">Drapeaux de la Fonction open()</mark>

La sortie de l'ex√©cution du programme est assez explicite, mais il y a certaines choses sur le code source qui n√©cessitent une explication suppl√©mentaire. Les fichiers `fcntl.h` et `sys/stat.h` ont d√ª √™tre inclus, puisque ces fichiers d√©finissent les drapeaux utilis√©s avec la fonction `open()`.

#### Modes d'Acc√®s (fcntl.h)

Le premier ensemble de drapeaux se trouve dans `fcntl.h` et est utilis√© pour d√©finir le mode d'acc√®s. Le mode d'acc√®s doit utiliser au moins un des trois drapeaux suivants :

| Drapeau    | Description                                         |
| ---------- | --------------------------------------------------- |
| `O_RDONLY` | Ouvrir le fichier pour un acc√®s lecture seule       |
| `O_WRONLY` | Ouvrir le fichier pour un acc√®s √©criture seule      |
| `O_RDWR`   | Ouvrir le fichier pour un acc√®s lecture et √©criture |

#### Drapeaux Optionnels

Ces drapeaux peuvent √™tre combin√©s avec plusieurs autres drapeaux optionnels en utilisant l'op√©rateur OU bit-√†-bit. Quelques-uns des plus courants et utiles de ces drapeaux sont :

| Drapeau    | Description                                         |
| ---------- | --------------------------------------------------- |
| `O_APPEND` | √âcrire les donn√©es √† la fin du fichier              |
| `O_TRUNC`  | Si le fichier existe d√©j√†, le tronquer √† 0 longueur |
| `O_CREAT`  | Cr√©er le fichier s'il n'existe pas                  |

### <mark style="color:blue;">Op√©rations Bit-√†-Bit</mark>

Les op√©rations bit-√†-bit combinent les bits en utilisant des portes logiques standard comme OU et ET. Quand deux bits entrent dans une porte OU, le r√©sultat est 1 si le premier bit ou le second bit est 1. Si deux bits entrent dans une porte ET, le r√©sultat est 1 seulement si √† la fois le premier bit et le second bit sont 1. Les valeurs compl√®tes de 32 bits peuvent utiliser ces op√©rateurs bit-√†-bit pour effectuer des op√©rations logiques sur chaque bit correspondant.

#### <mark style="color:green;">Exemple : bitwise.c</mark>

```c
#include <stdio.h>

int main() {
    int i, bit_a, bit_b;
    printf("op√©rateur OU bit-√†-bit |\n");
    for(i=0; i < 4; i++) {
        bit_a = (i & 2) / 2; // Obtient le second bit.
        bit_b = (i & 1);     // Obtient le premier bit.
        printf("%d | %d = %d\n", bit_a, bit_b, bit_a | bit_b);
    }
    printf("\nop√©rateur ET bit-√†-bit &\n");
    for(i=0; i < 4; i++) {
        bit_a = (i & 2) / 2; // Obtient le second bit.
        bit_b = (i & 1);     // Obtient le premier bit.
        printf("%d & %d = %d\n", bit_a, bit_b, bit_a & bit_b);
    }
}
```

#### R√©sultats

```bash
$ gcc bitwise.c
$ ./a.out
op√©rateur OU bit-√†-bit |
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1

op√©rateur ET bit-√†-bit &
0 & 0 = 0
0 & 1 = 0
1 & 0 = 0
1 & 1 = 1
```

### <mark style="color:green;">Exploration des Drapeaux : fcntl\_flags.c</mark>

Les drapeaux utilis√©s pour la fonction `open()` ont des valeurs qui correspondent √† des bits uniques. De cette fa√ßon, les drapeaux peuvent √™tre combin√©s en utilisant la logique OU sans d√©truire aucune information.

{% code fullWidth="true" %}
```c
#include <stdio.h>
#include <fcntl.h>

void display_flags(char *, unsigned int);
void binary_print(unsigned int);

int main(int argc, char *argv[]) {
    display_flags("O_RDONLY\t\t", O_RDONLY);
    display_flags("O_WRONLY\t\t", O_WRONLY);
    display_flags("O_RDWR\t\t\t", O_RDWR);
    printf("\n");
    display_flags("O_APPEND\t\t", O_APPEND);
    display_flags("O_TRUNC\t\t\t", O_TRUNC);
    display_flags("O_CREAT\t\t\t", O_CREAT);
    printf("\n");
    display_flags("O_WRONLY|O_APPEND|O_CREAT", O_WRONLY|O_APPEND|O_CREAT);
}

void display_flags(char *label, unsigned int value) {
    printf("%s\t: %d\t:", label, value);
    binary_print(value);
    printf("\n");
}

void binary_print(unsigned int value) {
    unsigned int mask = 0xff000000; // Commence avec un masque pour l'octet le plus haut.
    unsigned int shift = 256*256*256; // Commence avec un d√©calage pour l'octet le plus haut.
    unsigned int byte, byte_iterator, bit_iterator;
    
    for(byte_iterator=0; byte_iterator < 4; byte_iterator++) {
        byte = (value & mask) / shift; // Isole chaque octet.
        printf(" ");
        for(bit_iterator=0; bit_iterator < 8; bit_iterator++) { // Imprime les bits de l'octet.
            if(byte & 0x80) // Si le bit le plus haut dans l'octet n'est pas 0,
                printf("1"); // imprime un 1.
            else
                printf("0"); // Sinon, imprime un 0.
            byte *= 2; // D√©place tous les bits vers la gauche de 1.
        }
        mask /= 256;  // D√©place les bits dans mask vers la droite de 8.
        shift /= 256; // D√©place les bits dans shift vers la droite de 8.
    }
}
```
{% endcode %}

#### R√©sultats fcntl\_flags.c

```bash
$ gcc fcntl_flags.c
$ ./a.out
O_RDONLY        : 0    : 00000000 00000000 00000000 00000000
O_WRONLY        : 1    : 00000000 00000000 00000000 00000001
O_RDWR          : 2    : 00000000 00000000 00000000 00000010

O_APPEND        : 1024 : 00000000 00000000 00000100 00000000
O_TRUNC         : 512  : 00000000 00000000 00000010 00000000
O_CREAT         : 64   : 00000000 00000000 00000000 01000000

O_WRONLY|O_APPEND|O_CREAT : 1089 : 00000000 00000000 00000100 01000001
```

### <mark style="color:blue;">Utilisation des Drapeaux Bit-√†-Bit</mark>

Utiliser des drapeaux de bits en combinaison avec la logique bit-√†-bit est une technique efficace et couramment utilis√©e. Tant que chaque drapeau est un nombre qui n'a que des bits uniques activ√©s, l'effet de faire un OU bit-√†-bit sur ces valeurs est le m√™me que de les additionner. Dans `fcntl_flags.c`, 1 + 1024 + 64 = 1089. Cette technique ne fonctionne que quand tous les bits sont uniques.

***

### <mark style="color:blue;">Permissions de fichiers</mark>

Si le flag `O_CREAT` est utilis√© dans le mode d'acc√®s pour la fonction `open()`, un argument suppl√©mentaire est n√©cessaire pour d√©finir les permissions du fichier nouvellement cr√©√©.

Cet argument utilise des flags de bits d√©finis dans `sys/stat.h`, qui peuvent √™tre combin√©s entre eux en utilisant la logique OU bit √† bit.

#### Flags de permissions disponibles

* `S_IRUSR` : Donner la permission de lecture au propri√©taire du fichier
* `S_IWUSR` : Donner la permission d'√©criture au propri√©taire du fichier
* `S_IXUSR` : Donner la permission d'ex√©cution au propri√©taire du fichier
* `S_IRGRP` : Donner la permission de lecture au groupe
* `S_IWGRP` : Donner la permission d'√©criture au groupe
* `S_IXGRP` : Donner la permission d'ex√©cution au groupe
* `S_IROTH` : Donner la permission de lecture aux autres (tout le monde)
* `S_IWOTH` : Donner la permission d'√©criture aux autres (tout le monde)
* `S_IXOTH` : Donner la permission d'ex√©cution aux autres (tout le monde)

#### <mark style="color:green;">Les trois types de permissions</mark>

Les permissions de lecture, √©criture et ex√©cution peuvent √™tre activ√©es ou d√©sactiv√©es pour trois champs diff√©rents :

1. **User (utilisateur)** : Le propri√©taire du fichier
2. **Group (groupe)** : Les utilisateurs du groupe associ√© au fichier
3. **Other (autres)** : Tous les autres utilisateurs

#### <mark style="color:green;">Repr√©sentation textuelle des permissions</mark>

Ces permissions sont affich√©es au d√©but de la sortie `ls -l` sous forme de 9 caract√®res :

* Les 3 premiers caract√®res : permissions du **propri√©taire** (user)
* Les 3 suivants : permissions du **groupe** (group)
* Les 3 derniers : permissions des **autres** (other)

Chaque groupe de 3 caract√®res utilise :

* `r` pour **read** (lecture)
* `w` pour **write** (√©criture)
* `x` pour **execute** (ex√©cution)
* `-` pour **d√©sactiv√©**

Dans l'exemple ci-dessus, le programme `simplenote` a les trois permissions utilisateur activ√©es : `rwx`

#### <mark style="color:green;">Repr√©sentation num√©rique des permissions</mark>

Chaque permission correspond √† un flag de bit :

* **read (lecture)** = 4 (100 en binaire)
* **write (√©criture)** = 2 (010 en binaire)
* **execute (ex√©cution)** = 1 (001 en binaire)

Ces valeurs peuvent √™tre additionn√©es pour d√©finir les permissions avec la commande `chmod`.

#### <mark style="color:green;">Utilisation des valeurs num√©riques</mark>

```bash
reader@hacking:~/booksrc $ chmod 731 simplenote.c
reader@hacking:~/booksrc $ ls -l simplenote.c
-rwx-wx--x 1 reader reader 1826 2007-09-07 02:51 simplenote.c
```

La commande `chmod 731` signifie :

* **7** (4+2+1) pour l'utilisateur : read + write + execute
* **3** (2+1) pour le groupe : write + execute
* **1** pour les autres : execute seulement

#### <mark style="color:green;">Utilisation des symboles</mark>

```bash
reader@hacking:~/booksrc $ chmod ugo-wx simplenote.c
reader@hacking:~/booksrc $ ls -l simplenote.c
-r-------- 1 reader reader 1826 2007-09-07 02:51 simplenote.c
```

`ugo-wx` signifie : **Retirer** les permissions write et execute pour **u**ser, **g**roup et **o**ther.

```bash
reader@hacking:~/booksrc $ chmod u+w simplenote.c
reader@hacking:~/booksrc $ ls -l simplenote.c
-rw------- 1 reader reader 1826 2007-09-07 02:51 simplenote.c
```

`u+w` signifie : **Ajouter** la permission write pour l'**u**tilisateur.

***

## <mark style="color:red;">User IDs (Identifiants utilisateurs)</mark>

Chaque utilisateur sur un syst√®me Unix a un **num√©ro d'identifiant utilisateur unique**. Cet ID utilisateur peut √™tre affich√© en utilisant la commande `id`.

```bash
reader@hacking:~/booksrc $ id reader
uid=999(reader) gid=999(reader)
groups=999(reader),4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),4
4(video),46(plugdev),104(scanner),112(netdev),113(lpadmin),115(powerdev),117(a
dmin)

reader@hacking:~/booksrc $ id matrix
uid=500(matrix) gid=500(matrix) groups=500(matrix)

reader@hacking:~/booksrc $ id root
uid=0(root) gid=0(root) groups=0(root)
```

#### <mark style="color:green;">L'utilisateur root</mark>

L'utilisateur **root** avec l'ID utilisateur **0** est comme le compte administrateur, qui a un acc√®s complet au syst√®me.

#### Commandes de changement d'utilisateur

* **`su`** : Peut √™tre utilis√© pour basculer vers un utilisateur diff√©rent. Si cette commande est ex√©cut√©e en tant que root, elle peut √™tre faite sans mot de passe.
* **`sudo`** : Permet d'ex√©cuter une seule commande en tant qu'utilisateur root.

```bash
reader@hacking:~/booksrc $ sudo su jose
jose@hacking:/home/reader/booksrc $ id
uid=501(jose) gid=501(jose) groups=501(jose)
```

En tant qu'utilisateur `jose`, le programme simplenote s'ex√©cutera comme jose, mais il n'aura pas acc√®s au fichier `/tmp/notes`. Ce fichier appartient √† l'utilisateur `reader` et n'autorise les permissions de lecture et d'√©criture qu'√† son propri√©taire.

```bash
jose@hacking:/home/reader/booksrc $ ls -l /tmp/notes
-rw------- 1 reader reader 36 2007-09-07 05:20 /tmp/notes

jose@hacking:/home/reader/booksrc $ ./simplenote "a note for jose"
[DEBUG] buffer @ 0x804a008: 'a note for jose'
[DEBUG] datafile @ 0x804a070: '/tmp/notes'
[!!] Fatal Error in main() while opening file: Permission denied

jose@hacking:/home/reader/booksrc $ cat /tmp/notes
cat: /tmp/notes: Permission denied
```

### <mark style="color:blue;">Solution : La permission SetUID</mark>

La solution √† ce probl√®me dans Unix est la **permission set user ID (setuid)**. C'est un bit de permission de fichier suppl√©mentaire qui peut √™tre d√©fini en utilisant `chmod`.

**Quand un programme avec ce flag est ex√©cut√©, il s'ex√©cute avec l'ID utilisateur du propri√©taire du fichier.**

#### Exemple avec la commande chsh

```bash
reader@hacking:~/booksrc $ which chsh
/usr/bin/chsh

reader@hacking:~/booksrc $ ls -l /usr/bin/chsh /etc/passwd
-rw-r--r-- 1 root root 1424 2007-09-06 21:05 /etc/passwd
-rwsr-xr-x 1 root root 23920 2006-12-19 20:35 /usr/bin/chsh
```

Le programme `chsh` a le **flag setuid** activ√©, indiqu√© par un **`s`** dans la sortie `ls`. Puisque ce fichier appartient √† root et a la permission setuid activ√©e, le programme s'ex√©cutera comme utilisateur root quand n'importe quel utilisateur ex√©cute ce programme.

### <mark style="color:blue;">Real User ID vs Effective User ID</mark>

Un programme en cours d'ex√©cution a √† la fois :

* **Real User ID** (ID utilisateur r√©el) : L'ID de l'utilisateur qui a lanc√© le programme
* **Effective User ID** (ID utilisateur effectif) : L'ID avec lequel le programme s'ex√©cute actuellement

Ces IDs peuvent √™tre r√©cup√©r√©s en utilisant les fonctions `getuid()` et `geteuid()` respectivement.

#### <mark style="color:green;">Programme de d√©monstration : uid\_demo.c</mark>

```c
#include <stdio.h>

int main() {
    printf("real uid: %d\n", getuid());
    printf("effective uid: %d\n", geteuid());
}
```

<mark style="color:green;">**Test sans SetUID**</mark>

```bash
reader@hacking:~/booksrc $ gcc -o uid_demo uid_demo.c
reader@hacking:~/booksrc $ ls -l uid_demo
-rwxr-xr-x 1 reader reader 6825 2007-09-07 05:32 uid_demo

reader@hacking:~/booksrc $ ./uid_demo
real uid: 999
effective uid: 999
```

<mark style="color:green;">**Changement de propri√©taire vers root**</mark>

```bash
reader@hacking:~/booksrc $ sudo chown root:root ./uid_demo
reader@hacking:~/booksrc $ ls -l uid_demo
-rwxr-xr-x 1 root root 6825 2007-09-07 05:32 uid_demo

reader@hacking:~/booksrc $ ./uid_demo
real uid: 999
effective uid: 999
```

Les deux IDs restent 999 car c'est toujours l'ID de l'utilisateur qui ex√©cute le programme.

**Activation du SetUID**

```bash
reader@hacking:~/booksrc $ chmod u+s ./uid_demo
chmod: changing permissions of `./uid_demo': Operation not permitted

reader@hacking:~/booksrc $ sudo chmod u+s ./uid_demo
reader@hacking:~/booksrc $ ls -l uid_demo
-rwsr-xr-x 1 root root 6825 2007-09-07 05:32 uid_demo

reader@hacking:~/booksrc $ ./uid_demo
real uid: 999
effective uid: 0
```

Maintenant l'**effective user ID est 0 (root)**, ce qui signifie que le programme peut acc√©der aux fichiers en tant que root.

### <mark style="color:blue;">Application pratique : Programme de prise de notes multi-utilisateurs</mark>

#### Fichier d'en-t√™te : hacking.h

Pour √©viter de copier-coller les m√™mes fonctions utilitaires, nous cr√©ons un fichier d'en-t√™te :

{% code fullWidth="true" %}
```c
// hacking.h
// Une fonction pour afficher un message d'erreur puis quitter
void fatal(char *message) {
    char error_message[100];
    strcpy(error_message, "[!!] Fatal Error ");
    strncat(error_message, message, 83);
    perror(error_message);
    exit(-1);
}

// Une fonction wrapper malloc() avec v√©rification d'erreur
void *ec_malloc(unsigned int size) {
    void *ptr;
    ptr = malloc(size);
    if(ptr == NULL)
        fatal("in ec_malloc() on memory allocation");
    return ptr;
}
```
{% endcode %}

#### Syntaxe #include

* **`#include <filename>`** : Le compilateur cherche dans les chemins d'inclusion standard (comme `/usr/include/`)
* **`#include "filename"`** : Le compilateur cherche dans le r√©pertoire courant

#### Programme notetaker.c

{% code fullWidth="true" %}
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include "hacking.h"

void usage(char *prog_name, char *filename) {
    printf("Usage: %s <data to add to %s>\n", prog_name, filename);
    exit(0);
}

void fatal(char *);
void *ec_malloc(unsigned int);

int main(int argc, char *argv[]) {
    int userid, fd;
    char *buffer, *datafile;
    
    buffer = (char *) ec_malloc(100);
    datafile = (char *) ec_malloc(20);
    strcpy(datafile, "/var/notes");
    
    if(argc < 2)
        usage(argv[0], datafile);
    
    strcpy(buffer, argv[1]);
    
    printf("[DEBUG] buffer @ %p: '%s'\n", buffer, buffer);
    printf("[DEBUG] datafile @ %p: '%s'\n", datafile, datafile);
    
    // Ouverture du fichier
    fd = open(datafile, O_WRONLY|O_CREAT|O_APPEND, S_IRUSR|S_IWUSR);
    if(fd == -1)
        fatal("in main() while opening file");
    
    printf("[DEBUG] file descriptor is %d\n", fd);
    userid = getuid(); // Obtenir l'ID utilisateur r√©el
    
    // √âcriture des donn√©es
    if(write(fd, &userid, 4) == -1) // √âcrire l'ID utilisateur avant les donn√©es de note
        fatal("in main() while writing userid to file");
    write(fd, "\n", 1); // Terminer la ligne
    
    if(write(fd, buffer, strlen(buffer)) == -1) // √âcrire la note
        fatal("in main() while writing buffer to file");
    write(fd, "\n", 1); // Terminer la ligne
    
    // Fermeture du fichier
    if(close(fd) == -1)
        fatal("in main() while closing file");
    
    printf("Note has been saved.\n");
    free(buffer);
    free(datafile);
}
```
{% endcode %}

#### Compilation et configuration

```bash
reader@hacking:~/booksrc $ gcc -o notetaker notetaker.c
reader@hacking:~/booksrc $ sudo chown root:root ./notetaker
reader@hacking:~/booksrc $ sudo chmod u+s ./notetaker
reader@hacking:~/booksrc $ ls -l ./notetaker
-rwsr-xr-x 1 root root 9015 2007-09-07 05:48 ./notetaker
```

#### Test du programme

```bash
reader@hacking:~/booksrc $ ./notetaker "this is a test of multiuser notes"
[DEBUG] buffer @ 0x804a008: 'this is a test of multiuser notes'
[DEBUG] datafile @ 0x804a070: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved.

reader@hacking:~/booksrc $ ls -l /var/notes
-rw------- 1 root reader 39 2007-09-07 05:49 /var/notes
```

#### Analyse du contenu du fichier

```bash
reader@hacking:~/booksrc $ sudo hexdump -C /var/notes
00000000  e7 03 00 00 0a 74 68 69  73 20 69 73 20 61 20 74  |.....this is a t|
00000010  65 73 74 20 6f 66 20 6d  75 6c 74 69 75 73 65 72  |est of multiuser|
00000020  20 6e 6f 74 65 73 0a                              | notes.|

reader@hacking:~/booksrc $ pcalc 0x03e7
999     0x3e7   0y1111100111
```

Le fichier `/var/notes` contient l'ID utilisateur de reader (999) et la note. √Ä cause de l'architecture little-endian, les 4 bytes de l'entier 999 apparaissent invers√©s en hexad√©cimal (`e7 03 00 00`).

### <mark style="color:blue;">Programme de recherche : notesearch.c</mark>

Pour permettre aux utilisateurs de lire leurs propres notes, nous avons besoin d'un programme de recherche setuid root correspondant :

{% code fullWidth="true" %}
```c
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include "hacking.h"

#define FILENAME "/var/notes"

int print_notes(int, int, char *);     // Fonction d'impression des notes
int find_user_note(int, int);          // Chercher dans le fichier une note pour un utilisateur
int search_note(char *, char *);       // Fonction de recherche par mot-cl√©
void fatal(char *);                    // Gestionnaire d'erreur fatale

int main(int argc, char *argv[]) {
    int userid, printing=1, fd;
    char searchstring[100];
    
    if(argc > 1)                       // S'il y a un argument,
        strcpy(searchstring, argv[1]); // c'est la cha√Æne de recherche ;
    else                               // sinon,
        searchstring[0] = 0;           // la cha√Æne de recherche est vide.
    
    userid = getuid();
    fd = open(FILENAME, O_RDONLY);     // Ouvrir le fichier en lecture seule
    if(fd == -1)
        fatal("in main() while opening file for reading");
    
    while(printing)
        printing = print_notes(fd, userid, searchstring);
    
    printf("-------[ end of note data ]-------\n");
    close(fd);
}

// Fonction pour imprimer les notes d'un uid donn√© qui correspondent
// √† une cha√Æne de recherche optionnelle ;
// retourne 0 √† la fin du fichier, 1 s'il y a encore des notes.
int print_notes(int fd, int uid, char *searchstring) {
    int note_length;
    char byte=0, note_buffer[100];
    
    note_length = find_user_note(fd, uid);
    if(note_length == -1)              // Si la fin du fichier est atteinte,
        return 0;                      // retourner 0.
    
    read(fd, note_buffer, note_length); // Lire les donn√©es de la note
    note_buffer[note_length] = 0;       // Terminer la cha√Æne
    
    if(search_note(note_buffer, searchstring)) // Si searchstring trouv√©e,
        printf(note_buffer);                   // imprimer la note.
    
    return 1;
}

// Fonction pour trouver la prochaine note pour un userID donn√© ;
// retourne -1 si la fin du fichier est atteinte ;
// sinon, retourne la longueur de la note trouv√©e.
int find_user_note(int fd, int user_uid) {
    int note_uid=-1;
    unsigned char byte;
    int length;
    
    while(note_uid != user_uid) {      // Boucler jusqu'√† trouver une note pour user_uid
        if(read(fd, &note_uid, 4) != 4) // Lire les donn√©es uid
            return -1;                  // Si 4 bytes ne sont pas lus, retourner le code fin de fichier
        if(read(fd, &byte, 1) != 1)     // Lire le s√©parateur newline
            return -1;
        
        byte = length = 0;
        while(byte != '\n') {           // Calculer combien de bytes jusqu'√† la fin de ligne
            if(read(fd, &byte, 1) != 1) // Lire un seul byte
                return -1;              // Si le byte n'est pas lu, retourner le code fin de fichier
            length++;
        }
    }
    
    lseek(fd, length * -1, SEEK_CUR);  // Rembobiner la lecture du fichier de length bytes
    printf("[DEBUG] found a %d byte note for user id %d\n", length, note_uid);
    return length;
}

// Fonction pour chercher un mot-cl√© dans une note ;
// retourne 1 si une correspondance est trouv√©e, 0 s'il n'y a pas de correspondance.
int search_note(char *note, char *keyword) {
    int i, keyword_length, match=0;
    
    keyword_length = strlen(keyword);
    if(keyword_length == 0)            // S'il n'y a pas de cha√Æne de recherche,
        return 1;                      // toujours "correspondre".
    
    for(i=0; i < strlen(note); i++) {  // It√©rer sur les bytes de la note
        if(note[i] == keyword[match])  // Si le byte correspond au mot-cl√©,
            match++;                   // se pr√©parer √† v√©rifier le prochain byte ;
        else {                         // sinon,
            if(note[i] == keyword[0])  // si ce byte correspond au premier byte du mot-cl√©,
                match = 1;             // commencer le comptage des correspondances √† 1.
            else
                match = 0;             // Sinon il est √† z√©ro.
        }
        if(match == keyword_length)    // S'il y a une correspondance compl√®te,
            return 1;                  // retourner correspondant.
    }
    return 0;                          // Retourner non correspondant.
}
```
{% endcode %}

#### Nouvelles concepts dans ce code

1. **`lseek()`** : Utilis√© pour rembobiner la position de lecture dans le fichier
   * `lseek(fd, length * -1, SEEK_CUR)` dit au programme de d√©placer la position de lecture vers l'avant depuis la position actuelle de `length * -1` bytes (donc vers l'arri√®re)

#### <mark style="color:green;">Test avec plusieurs utilisateurs</mark>

```bash
# Compilation et configuration
reader@hacking:~/booksrc $ gcc -o notesearch notesearch.c
reader@hacking:~/booksrc $ sudo chown root:root ./notesearch
reader@hacking:~/booksrc $ sudo chmod u+s ./notesearch

# Test avec reader
reader@hacking:~/booksrc $ ./notesearch
[DEBUG] found a 34 byte note for user id 999
this is a test of multiuser notes
-------[ end of note data ]-------

# Test avec jose
reader@hacking:~/booksrc $ sudo su jose
jose@hacking:/home/reader/booksrc $ ./notetaker "This is a note for jose"
[DEBUG] buffer @ 0x804a008: 'This is a note for jose'
[DEBUG] datafile @ 0x804a070: '/var/notes'
[DEBUG] file descriptor is 3
Note has been saved.

jose@hacking:/home/reader/booksrc $ ./notesearch
[DEBUG] found a 24 byte note for user id 501
This is a note for jose
-------[ end of note data ]-------
```

<mark style="color:green;">**R√©sum√©**</mark>

La permission **setuid** permet de cr√©er des programmes multi-utilisateurs s√©curis√©s qui :

1. **S'ex√©cutent avec des privil√®ges √©lev√©s** (comme root) pour acc√©der aux fichiers syst√®me
2. **Maintiennent la s√©paration des donn√©es** entre les utilisateurs gr√¢ce √† la logique du programme
3. **Utilisent le real user ID** pour identifier √† quel utilisateur appartiennent les donn√©es
4. **Utilisent l'effective user ID** pour obtenir les permissions n√©cessaires pour acc√©der aux fichiers

C'est exactement ainsi que fonctionnent les programmes syst√®me comme `chsh` et `passwd` qui permettent √† n'importe quel utilisateur de modifier ses propres informations dans des fichiers syst√®me prot√©g√©s.

***

## <mark style="color:red;">Function Pointers</mark>

A pointer simply contains a memory address and is given a data type that describes where it points. Usually, pointers are used for variables; however, they can also be used for functions. The funcptr\_example.c program demonstrates the use of function pointers

### <mark style="color:blue;">Analyse du Code</mark>

#### Structure du Programme

```c
#include <stdio.h>

// Deux fonctions simples qui retournent des valeurs diff√©rentes
int func_one() {
    printf("This is function one\n");
    return 1;
}

int func_two() {
    printf("This is function two\n");
    return 2;
}

int main() {
    int value;
    int (*function_ptr)();  // D√©claration du pointeur de fonction
    
    // Premier appel via func_one
    function_ptr = func_one;
    printf("function_ptr is 0x%08x\n", function_ptr);
    value = function_ptr();
    printf("value returned was %d\n", value);
    
    // Deuxi√®me appel via func_two
    function_ptr = func_two;
    printf("function_ptr is 0x%08x\n", function_ptr);
    value = function_ptr();
    printf("value returned was %d\n", value);
}
```

#### D√©claration d'un Pointeur de Fonction

```c
int (*function_ptr)();
```

Cette ligne d√©clare un pointeur nomm√© `function_ptr` qui peut pointer vers une fonction qui :

* Ne prend aucun param√®tre `()`
* Retourne un `int`

**Syntaxe importante :** Les parenth√®ses autour de `*function_ptr` sont essentielles. Sans elles, `int *function_ptr()` d√©clarerait une fonction qui retourne un pointeur vers un int.

#### Affectation et Appel

```c
function_ptr = func_one;    // Affectation de l'adresse de la fonction
value = function_ptr();     // Appel indirect de la fonction
```

Le nom d'une fonction en C repr√©sente automatiquement son adresse, donc `func_one` √©quivaut √† `&func_one`.

### Analyse de la Sortie

```
function_ptr is 0x08048374
This is function one
value returned was 1
function_ptr is 0x0804838d
This is function two
value returned was 2
```

#### Observations Importantes

1. **Adresses m√©moire diff√©rentes :**
   * `func_one` : `0x08048374`
   * `func_two` : `0x0804838d`
2. **Segment de code :** Ces adresses se trouvent dans la section `.text` du programme, o√π le code ex√©cutable est stock√©.
3. **Proximit√© des adresses :** La diff√©rence entre les deux adresses (`0x0804838d - 0x08048374 = 0x19 = 25 bytes`) correspond approximativement √† la taille du code assembleur de `func_one`.

### Avantages des Pointeurs de Fonction

#### 1. Polymorphisme en C

```c
// Exemple d'utilisation avec un tableau de pointeurs
int (*operations[])(int, int) = {add, subtract, multiply, divide};
int result = operations[choice](a, b);
```

#### 2. Callbacks et Fonctions de Rappel

```c
void process_data(int *data, int size, int (*callback)(int)) {
    for(int i = 0; i < size; i++) {
        data[i] = callback(data[i]);
    }
}
```

#### 3. Programmation Modulaire

Les pointeurs de fonction permettent de s√©lectionner diff√©rents algorithmes ou comportements √† l'ex√©cution.

***

## <mark style="color:red;">Nombres Pseudo-al√©atoires</mark>

Puisque les ordinateurs sont des machines d√©terministes, il leur est impossible de produire de vrais nombres al√©atoires. Mais de nombreuses applications n√©cessitent une forme d'al√©atoire. Les fonctions de g√©n√©rateur de nombres pseudo-al√©atoires r√©pondent √† ce besoin en g√©n√©rant un flux de nombres qui est pseudo-al√©atoire. Ces fonctions peuvent produire une s√©quence de nombres apparemment al√©atoire d√©marr√©e √† partir d'un nombre graine ; cependant, la m√™me s√©quence exacte peut √™tre g√©n√©r√©e √† nouveau avec la m√™me graine. Les machines d√©terministes ne peuvent pas produire de v√©ritable al√©atoire, mais si la valeur graine de la fonction de g√©n√©ration pseudo-al√©atoire n'est pas connue, la s√©quence semblera al√©atoire. Le g√©n√©rateur doit √™tre amorc√© avec une valeur en utilisant la fonction srand(), et √† partir de ce point, la fonction rand() retournera un nombre pseudo-al√©atoire de 0 √† RAND\_MAX. Ces fonctions et RAND\_MAX sont d√©finis dans stdlib.h. Bien que les nombres que rand() retourne sembleront √™tre al√©atoires, ils d√©pendent de la valeur graine fournie √† srand().

Pour maintenir la pseudo-al√©atoire entre les ex√©cutions de programme subs√©quentes, le randomiseur doit √™tre amorc√© avec une valeur diff√©rente √† chaque fois. Une pratique courante est d'utiliser le nombre de secondes depuis l'√©poque (retourn√© par la fonction time()) comme graine. Le programme rand\_example.c d√©montre cette technique.

### <mark style="color:blue;">rand\_example.c</mark>

```c
#include <stdio.h>
#include <stdlib.h>
int main() {
int i;
printf("RAND_MAX is %u\n", RAND_MAX);
srand(time(0));
printf("random values from 0 to RAND_MAX\n");
for(i=0; i < 8; i++)
printf("%d\n", rand());
printf("random values from 1 to 20\n");
for(i=0; i < 8; i++)
printf("%d\n", (rand()%20)+1);
}
```

Remarquez comment l'op√©rateur modulus est utilis√© pour obtenir des valeurs al√©atoires de 1 √† 20.

```
reader@hacking:~/booksrc $ gcc rand_example.c
reader@hacking:~/booksrc $ ./a.out
RAND_MAX is 2147483647
random values from 0 to RAND_MAX
101815015288
1315541117
2080969327
450538726
710528035
907694519
1525415338
1843056422
random values from 1 to 20
2
3
8
5
9
1
4
20
reader@hacking:~/booksrc $ ./a.out
RAND_MAX is 2147483647
random values from 0 to RAND_MAX
678789658
577505284
1472754734
2134715072
1227404380
1746681907
341911720
93522744
random values from 1 to 20
6
16
12
19
8
19
2
1
reader@hacking:~/booksrc $
```

La sortie du programme affiche simplement des nombres al√©atoires. La pseudo-al√©atoire peut aussi √™tre utilis√©e pour des programmes plus complexes, comme vous le verrez dans le script final de cette section.
