# Getting Your Hands Dirty

## <mark style="color:red;">The x86 Processor</mark>

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-12 18-28-30.png" alt=""><figcaption></figcaption></figure>

The first four registers **(EAX, ECX, EDX, and EBX)** are known as general-purpose registers.&#x20;

These are called the&#x20;

* Accumulator,
* Counter
* Data&#x20;
* Base

Registers, respectively. They are used for a variety of purposes, but they mainly act as temporary variables for the CPU when it is executing machine instructions.

The second four registers **(ESP, EBP, ESI, and EDI)** are also general-purpose registers, but they are sometimes known as pointers and indexes.These stand for&#x20;

* Stack Pointer
* Base Pointer,
* Source Index
* Destination Index,

Respectively. The first two registers are called pointers because they store 32-bit addresses, which essentially point to that location in memory. These registers are fairly important to program execution and memory management

The last two registers are also technically pointers  which are commonly used to point to the source and destination when data needs to be read from or written to. There are load and store instructions\
that use these registers, but for the most part, these registers can be thought of as just simple general-purpose registers

{% hint style="warning" %}
The EIP register is the Instruction Pointer register, which points to the current instruction the processor is reading. Like a child pointing his finger at each word as he reads, the processor reads each instruction using the EIP register as its finger. Naturally, this register is quite important and will be used a lot while debugging
{% endhint %}

***

## <mark style="color:red;">Assembly Language</mark>

Since we are using Intel syntax assembly language for this book, our tools must be configured to use this syntax. Inside GDB, the disassembly syntax can be set to Intel by simply typing&#x20;

* **`set disassembly intel or set dis intel`**

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-12 18-56-22.png" alt=""><figcaption></figcaption></figure>

The assembly instructions in Intel syntax generally follow this style

```
operation <destination>, <source>
```

**The destination and source values will either be a register, a memory address, or a value**

For example, the instructions below will move the value from ESP to EBP and then subtract 8 from ESP\
(storing the result in ESP).

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 15-48-00.png" alt=""><figcaption></figcaption></figure>

**There are also operations that are used to control the flow of execution.**

* The cmp operation is used to compare values, and basically any operation beginning with j is used to jump to a different part of the code (depending on the result of the comparison).&#x20;

The example below first compares a 4-byte value located at EBP minus 4 with the number 9.&#x20;

* The next instruction is short- hand for jump if less than or equal to, referring to the result of the previous comparison.&#x20;
* If that value is less than or equal to 9, execution jumps to the instruction at 0x8048393. Otherwise, execution flows to the next instruction with an unconditional jump.

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 15-52-56.png" alt=""><figcaption></figcaption></figure>

{% hint style="warning" %}
The -g flag can be used by the GCC compiler to include extra debugging information, which will give GDB access to the source code.
{% endhint %}

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 15-54-55.png" alt=""><figcaption></figcaption></figure>

Notice that EIP contains a memory address that points to an instruction in the main() function‚Äôs disassembly (shown in bold).

{% hint style="warning" %}
The instructions before this (shown in italics) are collectively known as the function prologue and are gen-\
erated by the compiler to set up memory for the rest of the main() function‚Äôs local variables.
{% endhint %}

**The GDB debugger provides a direct method to examine memory, using the command x, which is short for examine.**&#x54;he examine command in GDB can be used to look at a certain address of memory in a variety of ways. This command expects two arguments when it‚Äôs used: the location in memory to examine and how to display that memory

The display format also uses a single-letter shorthand, which is optionally preceded by a count of how many items to examine. Some common format letters are as follows:

* o Display in octal.
* x Display in hexadecimal.
* u Display in unsigned, standard base-10 decimal.
* t Display in binary.

A number can also be prepended to the format of the examine com- mand to examine multiple units at the target address.

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 16-03-16.png" alt=""><figcaption></figcaption></figure>

The default size of a single unit is a four-byte unit called a word. The size of the display units for the examine command can be changed by adding a size letter to the end of the format letter. The valid size letters are as follows:

* b A single byte
* h A halfword, which is two bytes in size
* w A word, which is four bytes in size
* g A giant, which is eight bytes in size

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 16-11-11.png" alt=""><figcaption></figcaption></figure>

* Lorsqu‚Äôon utilise la commande **examine** (`x`) dans GDB, les octets apparaissent dans l‚Äôordre exact o√π ils sont stock√©s en m√©moire.
* Sur un processeur **x86**, les donn√©es sont stock√©es en **little-endian** :
  * Cela signifie que l‚Äôoctet **le moins significatif** est plac√© **en premier** (√† l‚Äôadresse la plus basse).
* Exemple :
  * Si on stocke la valeur `0x00fc45c7`, les octets sont en m√©moire dans cet ordre :
    * `0xc7` ‚Üí `0x45` ‚Üí `0xfc` ‚Üí `0x00`
  * Mais si GDB affiche cette valeur comme un **mot** (word = 4 octets) ou un **demi-mot** (halfword = 2 octets), il les r√©organise pour montrer la valeur num√©rique correcte (`0x45c7` ou `0x00fc45c7`).
* Donc :
  * Vue **octet par octet** ‚Üí ordre "naturel" en m√©moire (little-endian).
  * Vue **en mot ou demi-mot** ‚Üí ordre r√©arrang√© pour donner la valeur correcte.

üëâ En r√©sum√© : la diff√©rence que tu observes vient du fait que **l‚Äôarchitecture x86 utilise le little-endian**, et que **GDB adapte l‚Äôaffichage** selon la taille de donn√©e que tu demandes.

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 16-17-51.png" alt=""><figcaption></figcaption></figure>

* La commande **`x` (examine)** dans GDB permet non seulement de voir la m√©moire brute (en hexad√©cimal, d√©cimal, etc.), mais aussi de la convertir sous d‚Äôautres formes.
* Avec l‚Äôoption **`i`** (instruction), GDB **d√©sassemble** directement le code machine en **instructions assembleur lisibles**.
* Exemple :
  * En m√©moire brute tu vois les octets : `0xc7 0x45 0xfc 0x00 ...`
  *   Mais si tu fais `x/i $eip`, GDB traduit ces octets en :

      ```
      mov DWORD PTR [ebp-4], 0x0
      ```
* Tu peux examiner une seule instruction (`x/i $eip`) ou plusieurs d‚Äôun coup (`x/3i $eip`).
* Ainsi, GDB sait reconna√Ætre automatiquement que les octets que tu vois en m√©moire correspondent √† des **instructions assembleur** et il fait la conversion pour toi.

üëâ En r√©sum√© :

* `x/xb` ‚Üí m√©moire affich√©e octet par octet.
* `x/i` ‚Üí m√™mes octets, mais interpr√©t√©s comme **instructions assembleur**.

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 16-19-00.png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 16-23-06.png" alt=""><figcaption></figcaption></figure>

* Le registre **EBP** contient ici l‚Äôadresse `0xbffff808`.
* L‚Äôinstruction assembleur agit sur l‚Äôadresse **`EBP - 4`**, donc sur `0xbffff804`.
* On peut examiner cette zone m√©moire de plusieurs fa√ßons avec GDB :
  * **Directement avec l‚Äôadresse** (`x/4xb 0xbffff804`).
  * **En laissant GDB faire le calcul** (`x/4xb $ebp - 4`).
  * **En utilisant `print`** pour calculer (`print $ebp - 4`), qui stocke le r√©sultat dans une variable temporaire (`$1`) r√©utilisable ensuite (`x/4xb $1`).
* Peu importe la m√©thode, elles affichent toutes le m√™me contenu m√©moire (ici, quelques octets ‚Äúpoubelle‚Äù).
* Ces octets repr√©sentent la place r√©serv√©e pour la variable `i` en C (`int i;`).
* D√®s que l‚Äôinstruction `mov DWORD PTR [ebp-4],0x0` sera ex√©cut√©e avec **`nexti`**, ces 4 octets seront remplac√©s par `0x00 0x00 0x00 0x00` (la variable `i` sera initialis√©e √† 0).

üëâ En r√©sum√© : **plusieurs chemins m√®nent au m√™me endroit m√©moire** ; `EBP-4` correspond √† la variable locale `i`, et l‚Äôinstruction en cours va l‚Äôinitialiser √† z√©ro.

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 16-23-32.png" alt=""><figcaption></figcaption></figure>

* **Instruction `cmp`** : compare la variable `i` (stock√©e en m√©moire √† `[ebp-4]`) avec la valeur **9**.
* **Instruction `jle`** : _jump if less or equal_ ‚Üí si `i ‚â§ 9`, alors **EIP saute √† l‚Äôadresse `0x8048393`**.
* **Instruction `jmp`** (inconditionnelle) : si la condition pr√©c√©dente n‚Äô√©tait pas vraie, **EIP saute directement √† `0x80483a6`**.
* Ensemble, ces trois instructions forment une structure **if-then-else** en assembleur :
  * **Si `i ‚â§ 9` ‚Üí aller √† 0x8048393 (alors ‚Ä¶)**
  * **Sinon ‚Üí aller √† 0x80483a6 (sinon ‚Ä¶)**
* Comme `i = 0` (apr√®s l‚Äôinitialisation pr√©c√©dente), la comparaison `0 ‚â§ 9` est vraie.
* Donc, apr√®s ex√©cution des deux instructions (`cmp` + `jle`), **EIP se retrouve √† l‚Äôadresse `0x8048393`**.

üëâ En r√©sum√© : c‚Äôest la traduction assembleur du test `if (i <= 9)` de la boucle `for`.

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 16-25-05.png" alt=""><figcaption></figcaption></figure>

* Apr√®s la comparaison (`cmp`) et le saut conditionnel (`jle`), comme **0 ‚â§ 9**, l‚Äôex√©cution arrive √† **l‚Äôadresse `0x8048393`**.
* √Ä cette adresse, deux instructions apparaissent :
  * `mov DWORD PTR [esp],0x8048484` ‚Üí √©crit l‚Äôadresse **0x8048484** dans la pile (√† l‚Äôendroit point√© par `ESP`).
  * `call 0x80482a0 <printf@plt>` ‚Üí appelle la fonction `printf`.
* Le registre **ESP** contient la valeur `0xbffff800`, donc l‚Äôadresse `0x8048484` est stock√©e l√†.
*   Quand on examine la m√©moire √† **0x8048484**, on trouve les octets :

    ```
    0x48 0x65 0x6c 0x6c 0x6f ...
    ```
* Ces octets correspondent aux codes **ASCII** des lettres `"H e l l o"`.
* Autrement dit, `0x8048484` pointe vers la cha√Æne de caract√®res **"Hello, world!\n"** stock√©e dans le programme.
* L‚Äôinstruction `mov` met l‚Äôadresse de cette cha√Æne dans la pile, et `call printf` va l‚Äôafficher √† l‚Äô√©cran.

üëâ En r√©sum√© : le programme est en train d‚Äôex√©cuter **`printf("Hello, world!\n");`**, et GDB permet de voir comment l‚Äôadresse de la cha√Æne est plac√©e en m√©moire avant l‚Äôappel √† `printf`.

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 16-28-12.png" alt=""><figcaption></figcaption></figure>

{% hint style="info" %}
ASCII is an agreed-upon standard that maps all the characters on your keyboard (and some that aren‚Äôt) to fixed numbers. The bytes 0x48, 0x65, 0x6c, and 0x6f all correspond to letters in the alphabet on the ASCII table shown below. This table is found in the man page for ASCII, available on most Unix systems by typing man ascii.
{% endhint %}

GDB‚Äôs examine command also contains provisions for look-ing at this type of memory. The c format letter can be used to automatically look up a byte on the ASCII table, and the s format letter will display an entire string of character data.

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 16-29-41.png" alt=""><figcaption></figcaption></figure>

These commands reveal that the data string "Hello, world!\n" is stored at memory address 0x8048484.&#x20;

* This string is the argument for the printf() function, which indicates that moving the address of this string to the address stored in ESP (0x8048484) has something to do with this function.&#x20;
* The following output shows the data string‚Äôs address being moved into the address ESP is pointing to
* **Adresse `0x8048484`** : c‚Äôest l‚Äôendroit en m√©moire o√π se trouve la cha√Æne `"Hello, world!\n"`.
* **Instruction `mov DWORD PTR [esp],0x8048484`** : met l‚Äôadresse de cette cha√Æne dans la pile, √† l‚Äôadresse point√©e par **ESP**.
* Cette op√©ration pr√©pare l‚Äôargument pour la fonction `printf()`.
* **Instruction `call 0x80482a0 <printf@plt>`** : appelle `printf`, qui va utiliser l‚Äôadresse plac√©e dans la pile pour savoir quoi afficher.
*   Apr√®s ex√©cution de `call`, on voit le r√©sultat √† l‚Äô√©cran :

    ```
    Hello, world!
    ```
* En r√©sum√© :
  * Le `mov` = pr√©paration de l‚Äôargument.
  * Le `call` = ex√©cution de la fonction `printf`.
  * Le texte `"Hello, world!"` est effectivement affich√©.

üëâ Donc ce passage montre **comment une fonction en C re√ßoit ses arguments via la pile** avant d‚Äô√™tre ex√©cut√©e.

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 16-50-09.png" alt=""><figcaption></figcaption></figure>

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 16-50-41.png" alt=""><figcaption></figcaption></figure>

* Apr√®s l‚Äôappel √† `printf`, les instructions suivantes s‚Äôoccupent de la boucle `for`.
* **Instruction `lea eax, [ebp-4]`** : charge dans le registre `EAX` l‚Äôadresse de la variable `i` (stock√©e √† `[EBP-4]`).
* **Instruction `inc DWORD PTR [eax]`** : incr√©mente de **1** la valeur situ√©e √† l‚Äôadresse contenue dans `EAX` ‚Üí donc `i = i + 1`.
* R√©sultat : la variable `i`, qui valait **0**, devient **1**.
* **Instruction suivante : `jmp 0x804838b`** ‚Üí saut inconditionnel qui ram√®ne l‚Äôex√©cution au test de boucle (`cmp i, 9`).
* En r√©sum√© :
  * `lea` ‚Üí retrouve l‚Äôadresse de `i`.
  * `inc` ‚Üí incr√©mente `i`.
  * `jmp` ‚Üí ram√®ne le programme au d√©but de la boucle pour la prochaine it√©ration.

üëâ Ce bloc assembleur correspond directement √† la partie **`i++` et au retour au test** dans le `for(i=0; i<10; i++)`.

***

## <mark style="color:red;">Back to Basics (C)</mark>

### <mark style="color:blue;">Strings</mark>

***

#### <mark style="color:green;">1. Qu‚Äôest-ce qu‚Äôune cha√Æne de caract√®res ?</mark>

* Une cha√Æne (`string`) est en r√©alit√© un **tableau de caract√®res** (`char array`).
* Exemple : `"Hello, world!\n"` ‚Üí tableau de caract√®res se terminant par un **octet nul (`\0`)**.
* Le **`0` (ou `\0`)** sert de **d√©limiteur** pour indiquer la fin de la cha√Æne.

***

#### <mark style="color:green;">2. D√©claration d‚Äôun tableau de caract√®res</mark>

```c
char str_a[20];   // tableau de 20 caract√®res
```

* Les cases sont num√©rot√©es √† partir de **0**.
* Chaque caract√®re est stock√© dans une case :
  * `str_a[0] = 'H';`
  * `str_a[1] = 'e';` ‚Ä¶
* Le dernier caract√®re important est `\0` (null byte).

***

#### <mark style="color:green;">3. Exemple simple (char\_array.c)</mark>

```c
#include <stdio.h>
int main() {
    char str_a[20];
    str_a[0] = 'H';
    str_a[1] = 'e';
    str_a[2] = 'l';
    str_a[3] = 'l';
    str_a[4] = 'o';
    str_a[5] = ',';
    str_a[6] = ' ';
    str_a[7] = 'w';
    str_a[8] = 'o';
    str_a[9] = 'r';
    str_a[10] = 'l';
    str_a[11] = 'd';
    str_a[12] = '!';
    str_a[13] = '\n';
    str_a[14] = 0;  // fin de cha√Æne
    printf(str_a);
}
```

‚úÖ R√©sultat √† l‚Äôex√©cution : **Hello, world!**

***

#### <mark style="color:green;">4. Points importants</mark>

* Le tableau `str_a` a 20 cases ‚Üí 20 octets r√©serv√©s en m√©moire.
* Seulement **15 cases utilis√©es** (`Hello, world!\n\0`).
* Les octets restants sont du **‚Äúgarbage‚Äù** (non utilis√©s).
* Si on met `\0` plus t√¥t, la cha√Æne sera tronqu√©e.
  * Exemple : `str_a[5] = 0;` ‚Üí affichera seulement `"Hello"`.

***

#### <mark style="color:green;">5. Manipulation des cha√Ænes avec la biblioth√®que standard</mark>

* Comme remplir une cha√Æne caract√®re par caract√®re est fastidieux, on utilise `<string.h>`.
* Exemple avec **`strcpy()`** :

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str_a[20];
    strcpy(str_a, "Hello, world!\n");
    printf(str_a);
}
```

* `strcpy(destination, source);`
  * Copie `"Hello, world!\n\0"` dans `str_a`.
  * S‚Äôarr√™te automatiquement apr√®s avoir copi√© le **null byte**.

***

üëâ En r√©sum√© :

* Une **cha√Æne en C = tableau de char termin√© par `\0`**.
* Important pour toutes les fonctions (`printf`, `strcpy`, etc.) qui travaillent avec des cha√Ænes.
* La biblioth√®que `<string.h>` fournit des outils pratiques (`strcpy`, `strlen`, `strcmp`, etc.) pour √©viter de tout faire caract√®re par caract√®re.

***

#### <mark style="color:green;">1. Programme</mark> <mark style="color:green;"></mark><mark style="color:green;">`char_array2.c`</mark>

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str_a[20];
    strcpy(str_a, "Hello, world!\n");
    printf(str_a);
}
```

* **`str_a`** : tableau de 20 caract√®res.
* **`strcpy(str_a, "Hello, world!\n")`** : copie la cha√Æne source dans `str_a`.
* **`printf(str_a)`** : affiche la cha√Æne stock√©e dans `str_a`.

***

#### <mark style="color:green;">2. Compilation et d√©bogage</mark>

* Compiler avec debug info :

```bash
gcc -g -o char_array2 char_array2.c
gdb ./char_array2
```

* **Breakpoints** :
  * Avant `strcpy` (ligne 6)
  * Dans `strcpy` (fonction de biblioth√®que)
  * Avant `printf` (ligne 8)

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 17-08-57.png" alt=""><figcaption></figcaption></figure>

***

#### <mark style="color:green;">3. Observations avec GDB</mark>

* **EIP (Instruction Pointer)** :
  * Au breakpoint dans `main()` ‚Üí EIP pointe dans le code `main`.
  * Au breakpoint dans `strcpy()` ‚Üí EIP pointe dans le code de la **biblioth√®que partag√©e**.
  * Retour √† `main()` apr√®s l‚Äôex√©cution de `strcpy()`.
* **Stack & fonction calls** :
  * Chaque appel de fonction est enregistr√© dans la **pile (stack)**.
  * GDB : commande `bt` (backtrace) pour voir la trace des appels.
*   **Exemple backtrace** :

    ```
    #0 strcpy() from libc
    #1 main() at char_array2.c:7
    ```
* Le d√©bogueur montre comment **EIP passe de main() √† strcpy() et revient** apr√®s l‚Äôappel.

<figure><img src="../../../.gitbook/assets/Screenshot From 2025-09-14 17-10-20.png" alt=""><figcaption></figcaption></figure>

***

#### 4. Points cl√©s

* Les fonctions de cha√Æne comme `strcpy` sont stock√©es dans des **biblioth√®ques partag√©es**, donc leur adresse peut changer entre les ex√©cutions (ASLR).
* `strcpy` copie la cha√Æne jusqu‚Äôau **null byte** (`\0`).
* GDB permet de suivre :
  * L‚Äôex√©cution instruction par instruction (`x/i $eip`, `nexti`)
  * Les registres et la m√©moire (`i r`, `x/xw`)
  * La pile et les appels de fonction (`bt`)

***

#### 5. Observations de s√©curit√©

* L‚Äôadresse de `strcpy()` peut varier √† chaque ex√©cution √† cause d‚Äôun m√©canisme de **protection du kernel Linux** (ASLR).
* Ceci emp√™che certains types d‚Äôattaques bas√©es sur des adresses m√©moire fixes.

***

### <mark style="color:blue;">Types sign√©s, non sign√©s, longs et courts</mark>

<mark style="color:green;">**Types sign√©s et non sign√©s**</mark>

Par d√©faut, les valeurs num√©riques en C sont **sign√©es**, ce qui signifie qu'elles peuvent √™tre √† la fois n√©gatives et positives. En revanche, les valeurs **non sign√©es** n'autorisent pas les nombres n√©gatifs. Puisque tout se r√©sume finalement √† de la m√©moire, toutes les valeurs num√©riques doivent √™tre stock√©es en binaire, et les valeurs non sign√©es ont plus de sens en binaire.

#### <mark style="color:green;">Plages de valeurs</mark>

* **Entier 32 bits non sign√©** : peut contenir des valeurs de 0 (tous les bits √† 0) √† 4 294 967 295 (tous les bits √† 1)
* **Entier 32 bits sign√©** : fait toujours 32 bits, ce qui signifie qu'il ne peut avoir que l'une des 2¬≥¬≤ combinaisons de bits possibles. Cela permet aux entiers sign√©s 32 bits d'avoir une plage de ‚àí2 147 483 648 √† 2 147 483 647.

Essentiellement, l'un des bits sert de drapeau pour marquer la valeur comme positive ou n√©gative. Les valeurs sign√©es positives ressemblent aux valeurs non sign√©es, mais les nombres n√©gatifs sont stock√©s diff√©remment en utilisant une m√©thode appel√©e **compl√©ment √† deux**.

<mark style="color:green;">**Le compl√©ment √† deux**</mark>

Le compl√©ment √† deux repr√©sente les nombres n√©gatifs sous une forme adapt√©e aux additionneurs binaires. Quand une valeur n√©gative en compl√©ment √† deux est ajout√©e √† un nombre positif de m√™me magnitude, le r√©sultat sera 0.

#### M√©thode du compl√©ment √† deux :

1. √âcrire le nombre positif en binaire
2. Inverser tous les bits
3. Ajouter 1

Cela peut para√Ætre √©trange, mais cela fonctionne et permet d'additionner les nombres n√©gatifs avec les nombres positifs en utilisant de simples additionneurs binaires.

<mark style="color:green;">**Exemple pratique avec pcalc**</mark>

Ceci peut √™tre explor√© rapidement √† plus petite √©chelle en utilisant `pcalc`, une calculatrice simple pour programmeurs qui affiche les r√©sultats en formats d√©cimal, hexad√©cimal et binaire. Pour simplifier, des nombres 8 bits sont utilis√©s dans cet exemple.

```bash
reader@hacking:~/booksrc $ pcalc 0y01001001
73
0x49
0y1001001

reader@hacking:~/booksrc $ pcalc 0y10110110 + 1
183
0xb7
0y10110111

reader@hacking:~/booksrc $ pcalc 0y01001001 + 0y10110111
256
0x100
0y100000000
```

#### Explication :

1. La valeur binaire `01001001` correspond au nombre positif 73
2. Tous les bits sont invers√©s, et 1 est ajout√© pour obtenir la repr√©sentation en compl√©ment √† deux pour ‚àí73, soit `10110111`
3. Quand ces deux valeurs sont additionn√©es, le r√©sultat des 8 bits originaux est 0

Le programme `pcalc` affiche la valeur 256 car il ne sait pas que nous ne traitons que des valeurs 8 bits. Dans un additionneur binaire, ce bit de retenue serait simplement ignor√© car la fin de la m√©moire de la variable aurait √©t√© atteinte.

***

<mark style="color:green;">**D√©claration des variables en C**</mark>

#### <mark style="color:green;">Variables non sign√©es</mark>

En C, les variables peuvent √™tre d√©clar√©es comme non sign√©es en ajoutant simplement le mot-cl√© `unsigned` devant la d√©claration :

```c
unsigned int mon_entier;
```

#### Modification de la taille

La taille des variables num√©riques peut √™tre √©tendue ou raccourcie en ajoutant les mots-cl√©s `long` ou `short`. Les tailles r√©elles varieront selon l'architecture pour laquelle le code est compil√©.

#### <mark style="color:green;">La fonction sizeof()</mark>

Le langage C fournit une macro appel√©e `sizeof()` qui peut d√©terminer la taille de certains types de donn√©es. Elle fonctionne comme une fonction qui prend un type de donn√©es en entr√©e et retourne la taille d'une variable d√©clar√©e avec ce type pour l'architecture cible.

Programme d'exemple : datatype\_sizes.c

```c
#include <stdio.h>

int main() {
    printf("Le type 'int' fait\t\t %d octets\n", sizeof(int));
    printf("Le type 'unsigned int' fait\t %d octets\n", sizeof(unsigned int));
    printf("Le type 'short int' fait\t %d octets\n", sizeof(short int));
    printf("Le type 'long int' fait\t %d octets\n", sizeof(long int));
    printf("Le type 'long long int' fait\t %d octets\n", sizeof(long long int));
    printf("Le type 'float' fait\t\t %d octets\n", sizeof(float));
    printf("Le type 'char' fait\t\t %d octets\n", sizeof(char));
}
```

Ce morceau de code utilise la fonction `printf()` d'une mani√®re l√©g√®rement diff√©rente. Il utilise ce qu'on appelle un **sp√©cificateur de format** pour afficher la valeur retourn√©e par les appels √† la fonction `sizeof()`.

#### Compilation et ex√©cution :

```bash
reader@hacking:~/booksrc $ gcc datatype_sizes.c
reader@hacking:~/booksrc $ ./a.out
Le type 'int' fait                4 octets
Le type 'unsigned int' fait       4 octets
Le type 'short int' fait          2 octets
Le type 'long int' fait           4 octets
Le type 'long long int' fait      8 octets
Le type 'float' fait              4 octets
Le type 'char' fait               1 octets
```

***

### <mark style="color:blue;">Pointers</mark>

<mark style="color:green;">**Qu'est-ce qu'un pointeur ?**</mark>

Le registre EIP est un pointeur qui "pointe" vers l'instruction courante pendant l'ex√©cution d'un programme en contenant son adresse m√©moire. L'id√©e des pointeurs est aussi utilis√©e en C.

Puisque la m√©moire physique ne peut pas √™tre r√©ellement d√©plac√©e, les informations qu'elle contient doivent √™tre copi√©es. Il peut √™tre tr√®s co√ªteux en termes de calcul de copier de gros blocs de m√©moire pour les utiliser dans diff√©rentes fonctions ou √† diff√©rents endroits. C'est aussi co√ªteux du point de vue m√©moire, puisque l'espace pour la nouvelle copie de destination doit √™tre r√©serv√© ou allou√© avant que la source puisse √™tre copi√©e.

**Les pointeurs sont une solution √† ce probl√®me.** Au lieu de copier un gros bloc de m√©moire, il est beaucoup plus simple de transmettre l'adresse du d√©but de ce bloc de m√©moire.

<mark style="color:green;">**D√©finition des pointeurs en C**</mark>

Les pointeurs en C peuvent √™tre d√©finis et utilis√©s comme n'importe quel autre type de variable. Puisque la m√©moire sur l'architecture x86 utilise un adressage 32 bits, les pointeurs font aussi **32 bits (4 octets)**.

**Les pointeurs sont d√©finis en ajoutant un ast√©risque (\*) devant le nom de la variable.** Au lieu de d√©finir une variable de ce type, un pointeur est d√©fini comme quelque chose qui pointe vers des donn√©es de ce type.

<mark style="color:green;">**Exemple pratique : pointer.c**</mark>

Le programme `pointer.c` est un exemple d'un pointeur utilis√© avec le type de donn√©es `char`, qui ne fait qu'1 octet.

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str_a[20];     // Un tableau de caract√®res de 20 √©l√©ments
    char *pointer;      // Un pointeur, destin√© √† un tableau de caract√®res
    char *pointer2;     // Et encore un autre

    strcpy(str_a, "Hello, world!\n");
    pointer = str_a;    // Met le premier pointeur au d√©but du tableau.
    printf(pointer);    // L'affiche.
    
    pointer2 = pointer + 2; // Met le second 2 octets plus loin.
    printf(pointer2);   // L'affiche.
    
    strcpy(pointer2, "y you guys!\n"); // Copie √† cet endroit.
    printf(pointer);    // Affiche √† nouveau.
}
```

#### <mark style="color:green;">Explication du code</mark>

Comme l'indiquent les commentaires dans le code :

1. Le premier pointeur est plac√© au **d√©but du tableau de caract√®res**
2. Quand le tableau de caract√®res est r√©f√©renc√© de cette fa√ßon, c'est en fait un pointeur lui-m√™me
3. C'est ainsi que ce buffer a √©t√© pass√© comme pointeur aux fonctions `printf()` et `strcpy()`
4. Le second pointeur est mis √† l'adresse du premier pointeur **plus deux**
5. Puis certaines choses sont affich√©es

#### <mark style="color:green;">R√©sultat de l'ex√©cution</mark>

```bash
reader@hacking:~/booksrc $ gcc -o pointer pointer.c
reader@hacking:~/booksrc $ ./pointer
Hello, world!
llo, world!
Hey you guys!
reader@hacking:~/booksrc $
```

<mark style="color:green;">**Analyse avec GDB (D√©bogueur)**</mark>

Examinons ce programme plus en d√©tail avec GDB. Le programme est recompil√© avec les informations de d√©bogage, et un point d'arr√™t est plac√© sur la ligne 11 du code source. Cela arr√™tera le programme apr√®s que la cha√Æne "Hello, world!\n" ait √©t√© copi√©e dans le buffer `str_a` et que la variable `pointer` soit mise au d√©but de celui-ci.

```bash
reader@hacking:~/booksrc $ gcc -g -o pointer pointer.c
reader@hacking:~/booksrc $ gdb -q ./pointer
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".

(gdb) list
1       #include <stdio.h>
2       #include <string.h>
3
4       int main() {
5           char str_a[20];     // Un tableau de caract√®res de 20 √©l√©ments
6           char *pointer;      // Un pointeur, destin√© √† un tableau de caract√®res
7           char *pointer2;     // Et encore un autre
8
9           strcpy(str_a, "Hello, world!\n");
10          pointer = str_a;    // Met le premier pointeur au d√©but du tableau.

(gdb)
11          printf(pointer);
12
13          pointer2 = pointer + 2; // Met le second 2 octets plus loin.
14          printf(pointer2);   // L'affiche.
15          strcpy(pointer2, "y you guys!\n"); // Copie √† cet endroit.
16          printf(pointer);    // Affiche √† nouveau.
17      }

(gdb) break 11
Breakpoint 1 at 0x80483dd: file pointer.c, line 11.
(gdb) run
Starting program: /home/reader/booksrc/pointer

Breakpoint 1, main () at pointer.c:11
11          printf(pointer);
(gdb) x/xw pointer
0xbffff7e0:     0x6c6c6548
(gdb) x/s pointer
0xbffff7e0:     "Hello, world!\n"
(gdb)
```

#### <mark style="color:green;">Analyse des r√©sultats GDB</mark>

Quand le pointeur est examin√© comme une cha√Æne (`x/s pointer`), il est apparent que la cha√Æne donn√©e est l√† et est situ√©e √† l'adresse m√©moire **0xbffff7e0**.

**Point important :** Rappelez-vous que la cha√Æne elle-m√™me n'est pas stock√©e dans la variable pointeur‚Äîseule l'adresse m√©moire 0xbffff7e0 y est stock√©e.

**L'op√©rateur "adresse de" (&)**

Pour voir les **donn√©es r√©elles stock√©es dans la variable pointeur**, vous devez utiliser l'**op√©rateur "adresse de"**.

* L'op√©rateur "adresse de" est un **op√©rateur unaire** (il op√®re sur un seul argument)
* Cet op√©rateur est juste un **"et commercial" (&)** ajout√© devant un nom de variable
* Quand il est utilis√©, l'**adresse de cette variable** est retourn√©e, au lieu de la variable elle-m√™me
* Cet op√©rateur existe √† la fois dans GDB et dans le langage de programmation C

```bash
(gdb) x/xw &pointer
0xbffff7dc:     0xbffff7e0
(gdb) print &pointer
$1 = (char **) 0xbffff7dc
(gdb) print pointer
$2 = 0xbffff7e0 "Hello, world!\n"
(gdb)
```

#### <mark style="color:green;">Explication des adresses</mark>

Quand l'op√©rateur "adresse de" est utilis√©, voici ce qu'on d√©couvre :

* La variable `pointer` elle-m√™me est situ√©e √† l'adresse **0xbffff7dc** en m√©moire
* Elle **contient** l'adresse **0xbffff7e0** (qui est l'adresse o√π commence la cha√Æne "Hello, world!\n")

<mark style="color:green;">**Utilisation courante**</mark>

L'op√©rateur "adresse de" est souvent utilis√© en conjonction avec les pointeurs, puisque les pointeurs contiennent des adresses m√©moire. Le programme `addressof.c` d√©montre l'op√©rateur "adresse de" √©tant utilis√© pour mettre l'adresse d'une variable enti√®re dans un pointeur.

***

<mark style="color:$warning;">**L'op√©rateur adresse-de et le d√©r√©f√©rencement**</mark>

<mark style="color:green;">**Le programme addressof.c**</mark>

```c
#include <stdio.h>

int main() {
    int int_var = 5;
    int *int_ptr;
    int_ptr = &int_var; // Met l'adresse de int_var dans int_ptr
}
```

Le programme lui-m√™me n'affiche rien en r√©alit√©, mais vous pouvez probablement deviner ce qui se passe, m√™me avant de d√©boguer avec GDB.

<mark style="color:green;">**Analyse avec GDB**</mark>

```bash
reader@hacking:~/booksrc $ gcc -g addressof.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".

(gdb) list
1       #include <stdio.h>
2
3       int main() {
4           int int_var = 5;
5           int *int_ptr;
6
7           int_ptr = &int_var; // Met l'adresse de int_var dans int_ptr.
8       }

(gdb) break 8
Breakpoint 1 at 0x8048361: file addressof.c, line 8.
(gdb) run
Starting program: /home/reader/booksrc/a.out

Breakpoint 1, main () at addressof.c:8
8       }
(gdb) print int_var
$1 = 5
(gdb) print &int_var
$2 = (int *) 0xbffff804
(gdb) print int_ptr
$3 = (int *) 0xbffff804
(gdb) print &int_ptr
$4 = (int **) 0xbffff800
(gdb)
```

#### Explication des r√©sultats GDB

Comme d'habitude, un point d'arr√™t est plac√© et le programme est ex√©cut√© dans le d√©bogueur. √Ä ce moment, la majorit√© du programme s'est ex√©cut√©e.

* **`print int_var`** ‚Üí Montre la valeur de int\_var (5)
* **`print &int_var`** ‚Üí Montre son adresse en utilisant l'op√©rateur adresse-de (0xbffff804)
* **`print int_ptr`** ‚Üí Montre que int\_ptr contient l'adresse de int\_var (0xbffff804)
* **`print &int_ptr`** ‚Üí Montre l'adresse de int\_ptr lui-m√™me pour faire bonne mesure (0xbffff800)

<mark style="color:green;">**L'op√©rateur de d√©r√©f√©rencement**</mark>

Un op√©rateur unaire suppl√©mentaire appel√© **op√©rateur de d√©r√©f√©rencement** existe pour √™tre utilis√© avec les pointeurs. Cet op√©rateur retournera les donn√©es trouv√©es √† l'adresse vers laquelle le pointeur pointe, au lieu de l'adresse elle-m√™me. Il prend la forme d'un **ast√©risque devant le nom de la variable**, similaire √† la d√©claration d'un pointeur.

Une fois encore, l'op√©rateur de d√©r√©f√©rencement existe √† la fois dans GDB et en C. Utilis√© dans GDB, il peut r√©cup√©rer la valeur enti√®re vers laquelle int\_ptr pointe :

```bash
(gdb) print *int_ptr
$5 = 5
```

<mark style="color:green;">**Le programme addressof2.c am√©lior√©**</mark>

Quelques ajouts au code addressof.c (montr√©s dans addressof2.c) d√©montreront tous ces concepts. Les fonctions printf() ajout√©es utilisent des param√®tres de format, qui seront expliqu√©s dans la section suivante. Pour l'instant, concentrez-vous juste sur la sortie du programme.

```c
#include <stdio.h>

int main() {
    int int_var = 5;
    int *int_ptr;
    
    int_ptr = &int_var; // Met l'adresse de int_var dans int_ptr.
    
    printf("int_ptr = 0x%08x\n", int_ptr);
    printf("&int_ptr = 0x%08x\n", &int_ptr);
    printf("*int_ptr = 0x%08x\n\n", *int_ptr);
    
    printf("int_var est situ√©e √† 0x%08x et contient %d\n", &int_var, int_var);
    printf("int_ptr est situ√©e √† 0x%08x, contient 0x%08x, et pointe vers %d\n\n",
           &int_ptr, int_ptr, *int_ptr);
}
```

#### <mark style="color:green;">R√©sultat de la compilation et ex√©cution</mark>

```bash
reader@hacking:~/booksrc $ gcc addressof2.c
reader@hacking:~/booksrc $ ./a.out
int_ptr = 0xbffff834
&int_ptr = 0xbffff830
*int_ptr = 0x00000005

int_var est situ√©e √† 0xbffff834 et contient 5
int_ptr est situ√©e √† 0xbffff830, contient 0xbffff834, et pointe vers 5
reader@hacking:~/booksrc $
```

<mark style="color:green;">**Visualisation conceptuelle des op√©rateurs**</mark>

Quand les op√©rateurs unaires sont utilis√©s avec les pointeurs, on peut penser √† l'**op√©rateur adresse-de** comme **reculant**, tandis que l'**op√©rateur de d√©r√©f√©rencement** **avance** dans la direction vers laquelle le pointeur pointe.

```
Direction des op√©rateurs :
   ‚Üê & (reculer)     * (avancer) ‚Üí
Variable ‚Üê----------‚Üí Pointeur ‚Üê----------‚Üí Valeur point√©e
int_var              int_ptr                    5
```

#### R√©sum√© des trois op√©rations fondamentales

| Op√©rateur                | Syntaxe            | Description                              | R√©sultat          |
| ------------------------ | ------------------ | ---------------------------------------- | ----------------- |
| **D√©claration**          | `int *ptr;`        | Cr√©er un pointeur vers un entier         | Variable pointeur |
| **Adresse-de (&)**       | `ptr = &variable;` | Obtenir l'adresse de `variable`          | Adresse m√©moire   |
| **D√©r√©f√©rencement (\*)** | `valeur = *ptr;`   | Obtenir la valeur √† l'adresse dans `ptr` | Valeur stock√©e    |

***

### <mark style="color:blue;">Format Strings</mark>

<mark style="color:green;">**Introduction**</mark>

La fonction `printf()` peut √™tre utilis√©e pour imprimer plus que de simples cha√Ænes fixes. Cette fonction peut aussi utiliser des **cha√Ænes de format** pour imprimer des variables dans de nombreux formats diff√©rents.

Une cha√Æne de format est juste une cha√Æne de caract√®res avec des **s√©quences d'√©chappement sp√©ciales** qui disent √† la fonction d'ins√©rer des variables imprim√©es dans un format sp√©cifique √† la place de la s√©quence d'√©chappement.

Dans la fa√ßon dont la fonction `printf()` a √©t√© utilis√©e dans les programmes pr√©c√©dents, la cha√Æne "Hello, world!\n" est techniquement la cha√Æne de format ; cependant, elle ne contient aucune s√©quence d'√©chappement sp√©ciale.

<mark style="color:green;">Les param√®tres de format</mark>

Ces s√©quences d'√©chappement sont aussi appel√©es **param√®tres de format**, et pour chacun trouv√© dans la cha√Æne de format, la fonction s'attend √† recevoir un argument suppl√©mentaire. Chaque param√®tre de format commence par un **signe pour-cent (%)** et utilise un raccourci d'un seul caract√®re tr√®s similaire aux caract√®res de formatage utilis√©s par la commande examine de GDB.

#### Param√®tres de format pour les valeurs

| Param√®tre | Type de sortie    |
| --------- | ----------------- |
| `%d`      | D√©cimal           |
| `%u`      | D√©cimal non sign√© |
| `%x`      | Hexad√©cimal       |

Tous les param√®tres de format pr√©c√©dents re√ßoivent leurs donn√©es comme **valeurs**, pas comme pointeurs vers des valeurs.

#### Param√®tres de format pour les pointeurs

Il y a aussi quelques param√®tres de format qui attendent des pointeurs :

| Param√®tre | Type de sortie                         |
| --------- | -------------------------------------- |
| `%s`      | Cha√Æne                                 |
| `%n`      | Nombre d'octets √©crits jusqu'√† pr√©sent |

* Le param√®tre de format `%s` s'attend √† recevoir une **adresse m√©moire** ; il imprime les donn√©es √† cette adresse m√©moire jusqu'√† ce qu'un octet nul soit rencontr√©.
* Le param√®tre de format `%n` est unique en ce qu'il **√©crit r√©ellement des donn√©es**. Il s'attend aussi √† recevoir une adresse m√©moire, et il √©crit le nombre d'octets qui ont √©t√© √©crits jusqu'√† pr√©sent dans cette adresse m√©moire.

<mark style="color:green;">**Exemple pratique : fmt\_strings.c**</mark>

```c
#include <stdio.h>

int main() {
    char string[10];
    int A = -73;
    unsigned int B = 31337;
    
    strcpy(string, "sample");
    
    // Exemple d'impression avec diff√©rentes cha√Ænes de format
    printf("[A] Dec: %d, Hex: %x, Unsigned: %u\n", A, A, A);
    printf("[B] Dec: %d, Hex: %x, Unsigned: %u\n", B, B, B);
    printf("[largeur de champ sur B] 3: '%3u', 10: '%10u', '%08u'\n", B, B, B);
    printf("[string] %s Adresse %08x\n", string, string);
    
    // Exemple d'op√©rateur d'adresse unaire (d√©r√©f√©rencement) et d'une cha√Æne de format %x
    printf("la variable A est √† l'adresse: %08x\n", &A);
}
```

Dans le code pr√©c√©dent, des arguments variables suppl√©mentaires sont pass√©s √† chaque appel `printf()` pour chaque param√®tre de format dans la cha√Æne de format. Le dernier appel `printf()` utilise l'argument `&A`, qui fournira l'adresse de la variable A.

#### <mark style="color:green;">Compilation et ex√©cution</mark>

```bash
reader@hacking:~/booksrc $ gcc -o fmt_strings fmt_strings.c
reader@hacking:~/booksrc $ ./fmt_strings
[A] Dec: -73, Hex: ffffffb7, Unsigned: 4294967223
[B] Dec: 31337, Hex: 7a69, Unsigned: 31337
[largeur de champ sur B] 3: '31337', 10: '    31337', '00031337'
[string] sample Adresse bffff870
la variable A est √† l'adresse: bffff86c
reader@hacking:~/booksrc $
```

<mark style="color:green;">**Analyse des r√©sultats**</mark>

#### <mark style="color:green;">Affichage des variables A et B</mark>

Les deux premiers appels √† `printf()` d√©montrent l'impression des variables A et B, en utilisant diff√©rents param√®tres de format. Puisqu'il y a trois param√®tres de format dans chaque ligne, les variables A et B doivent √™tre fournies trois fois chacune.

* Le param√®tre de format `%d` permet les valeurs n√©gatives
* `%u` ne le permet pas, puisqu'il s'attend √† des valeurs non sign√©es

#### <mark style="color:green;">Comportement avec les nombres n√©gatifs</mark>

Quand la variable A est imprim√©e en utilisant le param√®tre de format `%u`, elle appara√Æt comme une valeur tr√®s √©lev√©e. C'est parce que A est un nombre n√©gatif stock√© en compl√©ment √† deux, et le param√®tre de format essaie de l'imprimer comme s'il s'agissait d'une valeur non sign√©e. Puisque le compl√©ment √† deux inverse tous les bits et ajoute un, les bits de poids fort qui √©taient z√©ro sont maintenant √† un.

#### <mark style="color:green;">Largeur de champ</mark>

La troisi√®me ligne de l'exemple, √©tiquet√©e `[largeur de champ sur B]`, montre l'utilisation de l'**option largeur de champ** dans un param√®tre de format. C'est juste un entier qui d√©signe la largeur de champ minimale pour ce param√®tre de format.

**Important :** Ce n'est pas une largeur de champ maximale‚Äîsi la valeur √† afficher est plus grande que la largeur de champ, la largeur de champ sera d√©pass√©e.

* `%3u` : Cela arrive quand 3 est utilis√©, puisque les donn√©es de sortie ont besoin de 5 octets
* `%10u` : Quand 10 est utilis√© comme largeur de champ, 5 octets d'espace vide sont affich√©s avant les donn√©es de sortie
* `%08u` : Si une valeur de largeur de champ commence par un 0, cela signifie que le champ devrait √™tre rembourr√© avec des z√©ros

#### <mark style="color:green;">Affichage de cha√Ænes</mark>

La quatri√®me ligne, √©tiquet√©e `[string]`, montre simplement l'utilisation du param√®tre de format `%s`. Rappelez-vous que la variable `string` est en fait un pointeur contenant l'adresse de la cha√Æne, ce qui fonctionne parfaitement, puisque le param√®tre de format `%s` s'attend √† ce que ses donn√©es soient pass√©es par r√©f√©rence.

#### <mark style="color:green;">Affichage d'adresses</mark>

La ligne finale montre juste l'adresse de la variable A, en utilisant l'op√©rateur d'adresse unaire pour d√©r√©f√©rencer la variable. Cette valeur est affich√©e comme huit chiffres hexad√©cimaux, rembourr√©s par des z√©ros.

<mark style="color:green;">R√©sum√© des bonnes pratiques</mark>

Comme ces exemples le montrent, vous devriez utiliser :

* `%d` pour d√©cimal
* `%u` pour non sign√©
* `%x` pour hexad√©cimal

Les largeurs de champ minimales peuvent √™tre d√©finies en mettant un nombre juste apr√®s le signe pour-cent, et si la largeur de champ commence par 0, elle sera rembourr√©e avec des z√©ros. Le param√®tre `%s` peut √™tre utilis√© pour imprimer des cha√Ænes et devrait recevoir l'adresse de la cha√Æne.

***

<mark style="color:green;">**La fonction scanf() pour l'entr√©e**</mark>

Les cha√Ænes de format sont utilis√©es par une famille enti√®re de fonctions I/O standard, y compris `scanf()`, qui fonctionne essentiellement comme `printf()` mais est utilis√©e pour l'**entr√©e** au lieu de la sortie.

**Diff√©rence cl√© :** La fonction `scanf()` s'attend √† ce que tous ses arguments soient des **pointeurs**, donc les arguments doivent √™tre des adresses de variables‚Äîpas les variables elles-m√™mes. Cela peut √™tre fait en utilisant des variables pointeur ou en utilisant l'op√©rateur d'adresse unaire pour r√©cup√©rer l'adresse des variables normales.

#### Exemple : input.c

```c
#include <stdio.h>
#include <string.h>

int main() {
    char message[10];
    int count, i;
    
    strcpy(message, "Hello, world!");
    
    printf("R√©p√©ter combien de fois ? ");
    scanf("%d", &count);
    
    for(i=0; i < count; i++)
        printf("%3d - %s\n", i, message);
}
```

Dans `input.c`, la fonction `scanf()` est utilis√©e pour d√©finir la variable `count`.

#### Ex√©cution du programme

```bash
reader@hacking:~/booksrc $ gcc -o input input.c
reader@hacking:~/booksrc $ ./input
R√©p√©ter combien de fois ? 3
  0 - Hello, world!
  1 - Hello, world!
  2 - Hello, world!

reader@hacking:~/booksrc $ ./input
R√©p√©ter combien de fois ? 12
  0 - Hello, world!
  1 - Hello, world!
  2 - Hello, world!
  3 - Hello, world!
  4 - Hello, world!
  5 - Hello, world!
  6 - Hello, world!
  7 - Hello, world!
  8 - Hello, world!
  9 - Hello, world!
 10 - Hello, world!
 11 - Hello, world!
reader@hacking:~/booksrc $
```

***

### <mark style="color:blue;">Typecasting</mark>

Le transtypage est simplement un moyen de changer temporairement le type de donn√©es d'une variable, malgr√© la fa√ßon dont elle a √©t√© d√©finie √† l'origine. Quand une variable est transtyp√©e vers un type diff√©rent, on dit essentiellement au compilateur de traiter cette variable comme si elle √©tait du nouveau type de donn√©es, mais seulement pour cette op√©ration. La syntaxe pour le transtypage est la suivante :

```c
(type_de_donn√©es_cible) variable
```

Ceci peut √™tre utilis√© lors de la manipulation d'entiers et de variables √† virgule flottante, comme le d√©montre `typecasting.c`.

#### Exemple : typecasting.c

```c
#include <stdio.h>

int main() {
    int a, b;
    float c, d;
    
    a = 13;
    b = 5;
    
    c = a / b;                          // Division utilisant des entiers
    d = (float) a / (float) b;          // Division d'entiers transtyp√©s en flottants
    
    printf("[entiers]\t a = %d\t b = %d\n", a, b);
    printf("[flottants]\t c = %f\t d = %f\n", c, d);
}
```

**R√©sultats de compilation et d'ex√©cution :**

```bash
reader@hacking:~/booksrc $ gcc typecasting.c
reader@hacking:~/booksrc $ ./a.out
[entiers]    a = 13    b = 5
[flottants]  c = 2.000000    d = 2.600000
reader@hacking:~/booksrc $
```

Comme discut√© pr√©c√©demment, diviser l'entier 13 par 5 arrondira vers le bas √† la r√©ponse incorrecte de 2, m√™me si cette valeur est stock√©e dans une variable √† virgule flottante. Cependant, si ces variables enti√®res sont transtyp√©es en flottants, elles seront trait√©es comme telles. Cela permet le calcul correct de 2.6.

***

#### <mark style="color:green;">**Transtypage avec les Pointeurs**</mark>

Cet exemple est illustratif, mais l√† o√π le transtypage brille vraiment, c'est quand il est utilis√© avec les variables de type pointeur. M√™me si un pointeur n'est qu'une adresse m√©moire, le compilateur C exige toujours un type de donn√©es pour chaque pointeur. Une raison pour cela est d'essayer de limiter les erreurs de programmation. Un pointeur d'entier ne devrait pointer que vers des donn√©es enti√®res, tandis qu'un pointeur de caract√®re ne devrait pointer que vers des donn√©es de caract√®re. Une autre raison est pour l'arithm√©tique de pointeurs. Un entier fait quatre octets en taille, tandis qu'un caract√®re ne prend qu'un seul octet.

#### Exemple : pointer\_types.c

```c
#include <stdio.h>

int main() {
    int i;
    char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};
    
    char *char_pointer;
    int *int_pointer;
    
    char_pointer = char_array;
    int_pointer = int_array;
    
    // It√©rer √† travers le tableau d'entiers avec int_pointer
    for(i=0; i < 5; i++) {
        printf("[pointeur entier] pointe vers %p, qui contient l'entier %d\n",
               int_pointer, *int_pointer);
        int_pointer = int_pointer + 1;
    }
    
    // It√©rer √† travers le tableau de caract√®res avec char_pointer
    for(i=0; i < 5; i++) {
        printf("[pointeur caract√®re] pointe vers %p, qui contient le caract√®re '%c'\n",
               char_pointer, *char_pointer);
        char_pointer = char_pointer + 1;
    }
}
```

**Sortie :**

```bash
reader@hacking:~/booksrc $ gcc pointer_types.c
reader@hacking:~/booksrc $ ./a.out
[pointeur entier] pointe vers 0xbffff7f0, qui contient l'entier 1
[pointeur entier] pointe vers 0xbffff7f4, qui contient l'entier 2
[pointeur entier] pointe vers 0xbffff7f8, qui contient l'entier 3
[pointeur entier] pointe vers 0xbffff7fc, qui contient l'entier 4
[pointeur entier] pointe vers 0xbffff800, qui contient l'entier 5
[pointeur caract√®re] pointe vers 0xbffff810, qui contient le caract√®re 'a'
[pointeur caract√®re] pointe vers 0xbffff811, qui contient le caract√®re 'b'
[pointeur caract√®re] pointe vers 0xbffff812, qui contient le caract√®re 'c'
[pointeur caract√®re] pointe vers 0xbffff813, qui contient le caract√®re 'd'
[pointeur caract√®re] pointe vers 0xbffff814, qui contient le caract√®re 'e'
reader@hacking:~/booksrc $
```

M√™me si la m√™me valeur de 1 est ajout√©e √† `int_pointer` et `char_pointer` dans leurs boucles respectives, le compilateur incr√©mente les adresses des pointeurs de montants diff√©rents. Puisqu'un `char` fait seulement 1 octet, le pointeur vers le prochain `char` serait naturellement aussi 1 octet plus loin. Mais puisqu'un entier fait 4 octets, un pointeur vers l'entier suivant doit √™tre 4 octets plus loin.

***

#### <mark style="color:green;">**Pointeurs avec Types Incompatibles**</mark>

#### Exemple : pointer\_types2.c

```c
#include <stdio.h>

int main() {
    int i;
    char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};
    
    char *char_pointer;
    int *int_pointer;
    
    // Le char_pointer et int_pointer pointent maintenant vers des types incompatibles
    char_pointer = int_array;
    int_pointer = char_array;
    
    for(i=0; i < 5; i++) {
        printf("[pointeur entier] pointe vers %p, qui contient le caract√®re '%c'\n",
               int_pointer, *int_pointer);
        int_pointer = int_pointer + 1;
    }
    
    for(i=0; i < 5; i++) {
        printf("[pointeur caract√®re] pointe vers %p, qui contient l'entier %d\n",
               char_pointer, *char_pointer);
        char_pointer = char_pointer + 1;
    }
}
```

**Avertissements du compilateur :**

```bash
reader@hacking:~/booksrc $ gcc pointer_types2.c
pointer_types2.c: In function `main':
pointer_types2.c:12: warning: assignment from incompatible pointer type
pointer_types2.c:13: warning: assignment from incompatible pointer type
reader@hacking:~/booksrc $
```

Dans une tentative de pr√©venir les erreurs de programmation, le compilateur donne des avertissements sur les pointeurs qui pointent vers des types de donn√©es incompatibles. Mais le compilateur et peut-√™tre le programmeur sont les seuls √† se soucier du type d'un pointeur.

***

#### <mark style="color:green;">Solution avec Transtypage</mark>

#### Exemple : pointer\_types3.c

```c
#include <stdio.h>

int main() {
    int i;
    char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};
    
    char *char_pointer;
    int *int_pointer;
    
    // Transtyper vers le type de donn√©es du pointeur
    char_pointer = (char *) int_array;
    int_pointer = (int *) char_array;
    
    for(i=0; i < 5; i++) {
        printf("[pointeur entier] pointe vers %p, qui contient le caract√®re '%c'\n",
               int_pointer, *int_pointer);
        int_pointer = (int *) ((char *) int_pointer + 1);
    }
    
    for(i=0; i < 5; i++) {
        printf("[pointeur caract√®re] pointe vers %p, qui contient l'entier %d\n",
               char_pointer, *char_pointer);
        char_pointer = (char *) ((int *) char_pointer + 1);
    }
}
```

***

#### <mark style="color:green;">Pointeurs void</mark>

En C, un pointeur `void` est un pointeur sans type, d√©fini par le mot-cl√© `void`. Les pointeurs `void` ne peuvent pas √™tre d√©r√©f√©renc√©s √† moins d'√™tre transtyp√©s, car le compilateur doit d'abord conna√Ætre quel type de donn√©es il manipule.

#### Exemple : pointer\_types4.c

```c
#include <stdio.h>

int main() {
    int i;
    char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};
    
    void *void_pointer;
    
    void_pointer = (void *) char_array;
    for(i=0; i < 5; i++) {
        printf("[pointeur caract√®re] pointe vers %p, qui contient le caract√®re '%c'\n",
               void_pointer, *((char *) void_pointer));
        void_pointer = (void *) ((char *) void_pointer + 1);
    }
    
    void_pointer = (void *) int_array;
    for(i=0; i < 5; i++) {
        printf("[pointeur entier] pointe vers %p, qui contient l'entier %d\n",
               void_pointer, *((int *) void_pointer));
        void_pointer = (void *) ((int *) void_pointer + 1);
    }
}
```

#### <mark style="color:green;">Approche Alternative avec Entier Non Sign√©</mark>

#### Exemple : pointer\_types5.c

```c
#include <stdio.h>

int main() {
    int i;
    char char_array[5] = {'a', 'b', 'c', 'd', 'e'};
    int int_array[5] = {1, 2, 3, 4, 5};
    
    unsigned int hacky_nonpointer;
    
    hacky_nonpointer = (unsigned int) char_array;
    for(i=0; i < 5; i++) {
        printf("[hacky_nonpointer] pointe vers %p, qui contient le caract√®re '%c'\n",
               hacky_nonpointer, *((char *) hacky_nonpointer));
        hacky_nonpointer = hacky_nonpointer + sizeof(char);
    }
    
    hacky_nonpointer = (unsigned int) int_array;
    for(i=0; i < 5; i++) {
        printf("[hacky_nonpointer] pointe vers %p, qui contient l'entier %d\n",
               hacky_nonpointer, *((int *) hacky_nonpointer));
        hacky_nonpointer = hacky_nonpointer + sizeof(int);
    }
}
```

***

### <mark style="color:blue;">Arguments de Ligne de Commande</mark>

Beaucoup de programmes non-graphiques re√ßoivent des entr√©es sous la forme d'arguments de ligne de commande. Contrairement √† la saisie avec `scanf()`, les arguments de ligne de commande ne n√©cessitent pas d'interaction utilisateur apr√®s que le programme ait commenc√© son ex√©cution. Cela tend √† √™tre plus efficace et constitue une m√©thode d'entr√©e utile.

En C, les arguments de ligne de commande peuvent √™tre accessibles dans la fonction `main()` en incluant deux arguments suppl√©mentaires √† la fonction : un entier et un pointeur vers un tableau de cha√Ænes. L'entier contiendra le nombre d'arguments, et le tableau de cha√Ænes contiendra chacun de ces arguments.

#### commandline.c

```c
#include <stdio.h>

int main(int arg_count, char *arg_list[]) {
    int i;
    printf("Il y avait %d arguments fournis :\n", arg_count);
    for(i=0; i < arg_count; i++)
        printf("argument #%d\t-\t%s\n", i, arg_list[i]);
}
```

#### R√©sultats d'ex√©cution

```bash
reader@hacking:~/booksrc $ gcc -o commandline commandline.c
reader@hacking:~/booksrc $ ./commandline
Il y avait 1 arguments fournis :
argument #0    -    ./commandline

reader@hacking:~/booksrc $ ./commandline this is a test
Il y avait 5 arguments fournis :
argument #0    -    ./commandline
argument #1    -    this
argument #2    -    is
argument #3    -    a
argument #4    -    test
reader@hacking:~/booksrc $
```

Le zeroth argument est toujours le nom du binaire en cours d'ex√©cution, et le reste du tableau d'arguments (souvent appel√© un vecteur d'arguments) contient les arguments restants sous forme de cha√Ænes.

#### <mark style="color:green;">Conversion de Cha√Ænes en Entiers</mark>

Parfois, un programme voudra utiliser un argument de ligne de commande comme un entier plut√¥t que comme une cha√Æne. Ind√©pendamment de cela, l'argument est pass√© comme une cha√Æne ; cependant, il existe des fonctions de conversion standard. Contrairement au transtypage simple, ces fonctions peuvent r√©ellement convertir des tableaux de caract√®res contenant des nombres en entiers r√©els. La plus commune de ces fonctions est `atoi()`, qui signifie ASCII vers entier (ASCII to integer). Cette fonction accepte un pointeur vers une cha√Æne come argument et retourne la valeur enti√®re qu'elle repr√©sente.

#### convert.c

```c
#include <stdio.h>

void usage(char *program_name) {
    printf("Usage : %s <message> <# de fois √† r√©p√©ter>\n", program_name);
    exit(1);
}

int main(int argc, char *argv[]) {
    int i, count;
    
    if(argc < 3)                    // Si moins de 3 arguments sont utilis√©s,
        usage(argv[0]);             // afficher le message d'usage et quitter.
    
    count = atoi(argv[2]);          // Convertir le 2√®me arg en entier.
    printf("R√©p√©tition %d fois..\n", count);
    
    for(i=0; i < count; i++)
        printf("%3d - %s\n", i, argv[1]);  // Afficher le 1er arg.
}
```

#### R√©sultats d'ex√©cution

```bash
reader@hacking:~/booksrc $ gcc convert.c
reader@hacking:~/booksrc $ ./a.out
Usage : ./a.out <message> <# de fois √† r√©p√©ter>

reader@hacking:~/booksrc $ ./a.out 'Bonjour, monde!' 3
R√©p√©tition 3 fois..
  0 - Bonjour, monde!
  1 - Bonjour, monde!
  2 - Bonjour, monde!
reader@hacking:~/booksrc $
```

***

#### <mark style="color:green;">Gestion des Erreurs et Violations de M√©moire</mark>

Dans le code pr√©c√©dent, une instruction `if` s'assure que trois arguments sont utilis√©s avant que ces cha√Ænes soient accessibles. Si le programme essaie d'acc√©der √† de la m√©moire qui n'existe pas ou pour laquelle le programme n'a pas la permission de lire, le programme plantera. En C, il est important de v√©rifier ces types de conditions et de les g√©rer dans la logique du programme.

#### convert2.c (Version sans v√©rification d'erreur)

```c
#include <stdio.h>

void usage(char *program_name) {
    printf("Usage : %s <message> <# de fois √† r√©p√©ter>\n", program_name);
    exit(1);
}

int main(int argc, char *argv[]) {
    int i, count;
    
    // if(argc < 3)                 // V√©rification d'erreur comment√©e !
    //     usage(argv[0]);
    
    count = atoi(argv[2]);          // Convertir le 2√®me arg en entier.
    printf("R√©p√©tition %d fois..\n", count);
    
    for(i=0; i < count; i++)
        printf("%3d - %s\n", i, argv[1]);  // Afficher le 1er arg.
}
```

#### R√©sultat avec erreur de segmentation

```bash
reader@hacking:~/booksrc $ gcc convert2.c
reader@hacking:~/booksrc $ ./a.out test
Erreur de segmentation (core dumped)
reader@hacking:~/booksrc $
```

Quand le programme ne re√ßoit pas assez d'arguments de ligne de commande, il essaie toujours d'acc√©der aux √©l√©ments du tableau d'arguments, m√™me s'ils n'existent pas. Cela r√©sulte en un plantage du programme d√ª √† une erreur de segmentation.

#### <mark style="color:green;">Comprendre les Erreurs de Segmentation</mark>

La m√©moire est divis√©e en segments (qui seront discut√©s plus tard), et certaines adresses m√©moire ne sont pas dans les limites des segments m√©moire auxquels le programme a acc√®s. Quand le programme tente d'acc√©der √† une adresse qui est hors limites, il plantera et mourra dans ce qu'on appelle une erreur de segmentation.

#### D√©bogage avec GDB

```bash
reader@hacking:~/booksrc $ gcc -g convert2.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) run test
Starting program: /home/reader/booksrc/a.out test

Program received signal SIGSEGV, Segmentation fault.
0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6

(gdb) where
#0  0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6
#1  0xb800183c in ?? ()
#2  0x00000000 in ?? ()

(gdb) break main
Breakpoint 1 at 0x8048419: file convert2.c, line 14.

(gdb) run test
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/reader/booksrc/a.out test

Breakpoint 1, main (argc=2, argv=0xbffff894) at convert2.c:14
14      count = atoi(argv[2]); // convertir le 2√®me arg en entier

(gdb) cont
Continuing.

Program received signal SIGSEGV, Segmentation fault.
0xb7ec819b in ?? () from /lib/tls/i686/cmov/libc.so.6

(gdb) x/3xw 0xbffff894
0xbffff894:     0xbffff9b3      0xbffff9ce      0x00000000

(gdb) x/s 0xbffff9b3
0xbffff9b3:     "/home/reader/booksrc/a.out"

(gdb) x/s 0xbffff9ce
0xbffff9ce:     "test"

(gdb) x/s 0x00000000
0x0:    <Address 0x0 out of bounds>

(gdb) quit
The program is running. Exit anyway? (y or n) y
reader@hacking:~/booksrc $
```

<mark style="color:green;">**Analyse du D√©bogage**</mark>

Le programme est ex√©cut√© avec un seul argument de ligne de commande `test` dans GDB, ce qui cause le plantage du programme. La commande `where` montrera parfois une trace utile de la pile ; cependant, dans ce cas, la pile √©tait trop endommag√©e lors du plantage.

Un point d'arr√™t est plac√© sur `main` et le programme est r√©-ex√©cut√© pour obtenir la valeur du vecteur d'arguments. Puisque le vecteur d'arguments est un pointeur vers une liste de cha√Ænes, c'est en r√©alit√© un pointeur vers une liste de pointeurs.

L'utilisation de la commande `x/3xw` pour examiner les trois premi√®res adresses m√©moire stock√©es √† l'adresse du vecteur d'arguments montre qu'elles sont elles-m√™mes des pointeurs vers des cha√Ænes :

1. **Le premier** est le zeroth argument (`./a.out`)
2. **Le second** est l'argument `test`
3. **Le troisi√®me** est z√©ro, qui est hors limites

Quand le programme essaie d'acc√©der √† cette adresse m√©moire, il plante avec une erreur de segmentation.

***

### <mark style="color:blue;">Port√©e des Variables</mark>

Un autre concept int√©ressant concernant la m√©moire en C est la port√©e des variables ou le contexte‚Äîen particulier, les contextes des variables au sein des fonctions. Chaque fonction a son propre ensemble de variables locales, qui sont ind√©pendantes de tout le reste. En fait, plusieurs appels √† la m√™me fonction ont tous leurs propres contextes.

#### <mark style="color:green;">Variables Locales dans les Fonctions</mark>

#### Exemple : scope.c

```c
#include <stdio.h>

void func3() {
    int i = 11;
    printf("\t\t\t[dans func3] i = %d\n", i);
}

void func2() {
    int i = 7;
    printf("\t\t[dans func2] i = %d\n", i);
    func3();
    printf("\t\t[retour dans func2] i = %d\n", i);
}

void func1() {
    int i = 5;
    printf("\t[dans func1] i = %d\n", i);
    func2();
    printf("\t[retour dans func1] i = %d\n", i);
}

int main() {
    int i = 3;
    printf("[dans main] i = %d\n", i);
    func1();
    printf("[retour dans main] i = %d\n", i);
}
```

#### R√©sultat d'ex√©cution

```bash
reader@hacking:~/booksrc $ gcc scope.c
reader@hacking:~/booksrc $ ./a.out
[dans main] i = 3
[dans func1] i = 5
[dans func2] i = 7
[dans func3] i = 11
[retour dans func2] i = 7
[retour dans func1] i = 5
[retour dans main] i = 3
reader@hacking:~/booksrc $
```

Dans chaque fonction, la variable `i` est d√©finie avec une valeur diff√©rente et affich√©e. Remarquez que dans la fonction `main()`, la variable `i` vaut 3, m√™me apr√®s avoir appel√© `func1()` o√π la variable `i` vaut 5. De m√™me, dans `func1()`, la variable `i` reste √† 5, m√™me apr√®s avoir appel√© `func2()` o√π `i` vaut 7, et ainsi de suite. La meilleure fa√ßon de concevoir cela est que chaque appel de fonction a sa propre version de la variable `i`.

#### <mark style="color:green;">Variables Globales</mark>

Les variables peuvent aussi avoir une port√©e globale, ce qui signifie qu'elles persisteront √† travers toutes les fonctions. Les variables sont globales si elles sont d√©finies au d√©but du code, en dehors de toute fonction.

#### Exemple : scope2.c

```c
#include <stdio.h>

int j = 42; // j est une variable globale.

void func3() {
    int i = 11, j = 999; // Ici, j est une variable locale de func3().
    printf("\t\t\t[dans func3] i = %d, j = %d\n", i, j);
}

void func2() {
    int i = 7;
    printf("\t\t[dans func2] i = %d, j = %d\n", i, j);
    printf("\t\t[dans func2] d√©finition j = 1337\n");
    j = 1337; // √âcriture dans j
    func3();
    printf("\t\t[retour dans func2] i = %d, j = %d\n", i, j);
}

void func1() {
    int i = 5;
    printf("\t[dans func1] i = %d, j = %d\n", i, j);
    func2();
    printf("\t[retour dans func1] i = %d, j = %d\n", i, j);
}

int main() {
    int i = 3;
    printf("[dans main] i = %d, j = %d\n", i, j);
    func1();
    printf("[retour dans main] i = %d, j = %d\n", i, j);
}
```

#### R√©sultat d'ex√©cution

```bash
reader@hacking:~/booksrc $ gcc scope2.c
reader@hacking:~/booksrc $ ./a.out
[dans main] i = 3, j = 42
[dans func1] i = 5, j = 42
[dans func2] i = 7, j = 42
[dans func2] d√©finition j = 1337
[dans func3] i = 11, j = 999
[retour dans func2] i = 7, j = 1337
[retour dans func1] i = 5, j = 1337
[retour dans main] i = 3, j = 1337
reader@hacking:~/booksrc $
```

Dans la sortie, la variable globale `j` est modifi√©e dans `func2()`, et le changement persiste dans toutes les fonctions sauf `func3()`, qui a sa propre variable locale appel√©e `j`. Dans ce cas, le compilateur pr√©f√®re utiliser la variable locale.

#### <mark style="color:green;">Visualisation des Adresses M√©moire</mark>

Avec toutes ces variables utilisant les m√™mes noms, cela peut √™tre un peu confus, mais rappelez-vous qu'au final, tout n'est que de la m√©moire. La variable globale `j` est juste stock√©e en m√©moire, et chaque fonction est capable d'acc√©der √† cette m√©moire. Les variables locales pour chaque fonction sont chacune stock√©es dans leurs propres emplacements en m√©moire, ind√©pendamment des noms identiques.

#### Exemple : scope3.c

```c
#include <stdio.h>

int j = 42; // j est une variable globale.

void func3() {
    int i = 11, j = 999; // Ici, j est une variable locale de func3().
    printf("\t\t\t[dans func3] i @ 0x%08x = %d\n", &i, i);
    printf("\t\t\t[dans func3] j @ 0x%08x = %d\n", &j, j);
}

void func2() {
    int i = 7;
    printf("\t\t[dans func2] i @ 0x%08x = %d\n", &i, i);
    printf("\t\t[dans func2] j @ 0x%08x = %d\n", &j, j);
    printf("\t\t[dans func2] d√©finition j = 1337\n");
    j = 1337; // √âcriture dans j
    func3();
    printf("\t\t[retour dans func2] i @ 0x%08x = %d\n", &i, i);
    printf("\t\t[retour dans func2] j @ 0x%08x = %d\n", &j, j);
}

void func1() {
    int i = 5;
    printf("\t[dans func1] i @ 0x%08x = %d\n", &i, i);
    printf("\t[dans func1] j @ 0x%08x = %d\n", &j, j);
    func2();
    printf("\t[retour dans func1] i @ 0x%08x = %d\n", &i, i);
    printf("\t[retour dans func1] j @ 0x%08x = %d\n", &j, j);
}

int main() {
    int i = 3;
    printf("[dans main] i @ 0x%08x = %d\n", &i, i);
    printf("[dans main] j @ 0x%08x = %d\n", &j, j);
    func1();
    printf("[retour dans main] i @ 0x%08x = %d\n", &i, i);
    printf("[retour dans main] j @ 0x%08x = %d\n", &j, j);
}
```

#### R√©sultat avec adresses m√©moire

```bash
reader@hacking:~/booksrc $ gcc scope3.c
reader@hacking:~/booksrc $ ./a.out
[dans main] i @ 0xbffff834 = 3
[dans main] j @ 0x08049988 = 42
[dans func1] i @ 0xbffff814 = 5
[dans func1] j @ 0x08049988 = 42
[dans func2] i @ 0xbffff7f4 = 7
[dans func2] j @ 0x08049988 = 42
[dans func2] d√©finition j = 1337
[dans func3] i @ 0xbffff7d4 = 11
[dans func3] j @ 0xbffff7d0 = 999
[retour dans func2] i @ 0xbffff7f4 = 7
[retour dans func2] j @ 0x08049988 = 1337
[retour dans func1] i @ 0xbffff814 = 5
[retour dans func1] j @ 0x08049988 = 1337
[retour dans main] i @ 0xbffff834 = 3
[retour dans main] j @ 0x08049988 = 1337
reader@hacking:~/booksrc $
```

Dans cette sortie, il est √©vident que la variable `j` utilis√©e par `func3()` est diff√©rente du `j` utilis√© par les autres fonctions. Le `j` utilis√© par `func3()` est situ√© √† `0xbffff7d0`, tandis que le `j` utilis√© par les autres fonctions est situ√© √† `0x08049988`. Aussi, remarquez que la variable `i` est en fait √† une adresse m√©moire diff√©rente pour chaque fonction.

#### <mark style="color:green;">Analyse avec GDB et Stack Frames</mark>

#### Session de d√©bogage

```bash
reader@hacking:~/booksrc $ gcc -g scope3.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) list 1
1       #include <stdio.h>
2
3       int j = 42; // j est une variable globale.
4
5       void func3() {
6           int i = 11, j = 999; // Ici, j est une variable locale de func3().
7           printf("\t\t\t[dans func3] i @ 0x%08x = %d\n", &i, i);
8           printf("\t\t\t[dans func3] j @ 0x%08x = %d\n", &j, j);
9       }
10
(gdb) break 7
Breakpoint 1 at 0x8048388: file scope3.c, line 7.
(gdb) run
Starting program: /home/reader/booksrc/a.out
[dans main] i @ 0xbffff804 = 3
[dans main] j @ 0x08049988 = 42
[dans func1] i @ 0xbffff7e4 = 5
[dans func1] j @ 0x08049988 = 42
[dans func2] i @ 0xbffff7c4 = 7
[dans func2] j @ 0x08049988 = 42
[dans func2] d√©finition j = 1337

Breakpoint 1, func3 () at scope3.c:7
7           printf("\t\t\t[dans func3] i @ 0x%08x = %d\n", &i, i);
(gdb) bt
#0  func3 () at scope3.c:7
#1  0x0804841d in func2 () at scope3.c:17
#2  0x0804849f in func1 () at scope3.c:26
#3  0x0804852b in main () at scope3.c:35
```

Le backtrace montre aussi les appels de fonctions imbriqu√©s en regardant les enregistrements conserv√©s sur la pile. Chaque fois qu'une fonction est appel√©e, un enregistrement appel√© stack frame (cadre de pile) est plac√© sur la pile. Chaque ligne dans le backtrace correspond √† un stack frame.

#### Backtrace complet avec variables locales

```bash
(gdb) bt full
#0  func3 () at scope3.c:7
        i = 11
        j = 999
#1  0x0804841d in func2 () at scope3.c:17
        i = 7
#2  0x0804849f in func1 () at scope3.c:26
        i = 5
#3  0x0804852b in main () at scope3.c:35
        i = 3
(gdb)
```

Le backtrace complet montre clairement que la variable locale `j` n'existe que dans le contexte de `func3()`. La version globale de la variable `j` est utilis√©e dans les contextes des autres fonctions.

#### <mark style="color:green;">Variables Statiques</mark>

En plus des variables globales, les variables peuvent aussi √™tre d√©finies comme variables statiques en pr√©fixant le mot-cl√© `static` √† la d√©finition de la variable. Similaires aux variables globales, une variable statique reste intacte entre les appels de fonctions ; cependant, les variables statiques sont aussi semblables aux variables locales puisqu'elles restent locales dans un contexte de fonction particulier. Une caract√©ristique diff√©rente et unique des variables statiques est qu'elles ne sont initialis√©es qu'une seule fois.

#### Exemple : static.c

```c
#include <stdio.h>

void function() { // Une fonction exemple, avec son propre contexte
    int var = 5;
    static int static_var = 5; // Initialisation de variable statique
    
    printf("\t[dans function] var = %d\n", var);
    printf("\t[dans function] static_var = %d\n", static_var);
    
    var++;          // Ajouter un √† var.
    static_var++;   // Ajouter un √† static_var.
}

int main() { // La fonction main, avec son propre contexte
    int i;
    static int static_var = 1337; // Une autre statique, dans un contexte diff√©rent
    
    for(i=0; i < 5; i++) { // Boucle 5 fois.
        printf("[dans main] static_var = %d\n", static_var);
        function(); // Appeler la fonction.
    }
}
```

#### R√©sultat des variables statiques

```bash
reader@hacking:~/booksrc $ gcc static.c
reader@hacking:~/booksrc $ ./a.out
[dans main] static_var = 1337
[dans function] var = 5
[dans function] static_var = 5
[dans main] static_var = 1337
[dans function] var = 5
[dans function] static_var = 6
[dans main] static_var = 1337
[dans function] var = 5
[dans function] static_var = 7
[dans main] static_var = 1337
[dans function] var = 5
[dans function] static_var = 8
[dans main] static_var = 1337
[dans function] var = 5
[dans function] static_var = 9
reader@hacking:~/booksrc $
```

Remarquez que `static_var` conserve sa valeur entre les appels successifs √† `function()`. C'est parce que les variables statiques conservent leurs valeurs, mais aussi parce qu'elles ne sont initialis√©es qu'une seule fois. De plus, puisque les variables statiques sont locales √† un contexte fonctionnel particulier, la `static_var` dans le contexte de `main()` conserve sa valeur de 1337 tout le temps.

#### <mark style="color:green;">Adresses M√©moire des Variables Statiques</mark>

#### Exemple : static2.c

```c
#include <stdio.h>

void function() { // Une fonction exemple, avec son propre contexte
    int var = 5;
    static int static_var = 5; // Initialisation de variable statique
    
    printf("\t[dans function] var @ %p = %d\n", &var, var);
    printf("\t[dans function] static_var @ %p = %d\n", &static_var, static_var);
    
    var++;          // Ajouter 1 √† var.
    static_var++;   // Ajouter 1 √† static_var.
}

int main() { // La fonction main, avec son propre contexte
    int i;
    static int static_var = 1337; // Une autre statique, dans un contexte diff√©rent
    
    for(i=0; i < 5; i++) { // Boucle 5 fois
        printf("[dans main] static_var @ %p = %d\n", &static_var, static_var);
        function(); // Appeler la fonction.
    }
}
```

#### R√©sultat avec adresses m√©moire

```bash
reader@hacking:~/booksrc $ gcc static2.c
reader@hacking:~/booksrc $ ./a.out
[dans main] static_var @ 0x804968c = 1337
[dans function] var @ 0xbffff814 = 5
[dans function] static_var @ 0x8049688 = 5
[dans main] static_var @ 0x804968c = 1337
[dans function] var @ 0xbffff814 = 5
[dans function] static_var @ 0x8049688 = 6
[dans main] static_var @ 0x804968c = 1337
[dans function] var @ 0xbffff814 = 5
[dans function] static_var @ 0x8049688 = 7
[dans main] static_var @ 0x804968c = 1337
[dans function] var @ 0xbffff814 = 5
[dans function] static_var @ 0x8049688 = 8
[dans main] static_var @ 0x804968c = 1337
[dans function] var @ 0xbffff814 = 5
[dans function] static_var @ 0x8049688 = 9
reader@hacking:~/booksrc $
```

Points Cl√©s √† Retenir

1. **Variables locales** : Chaque fonction a ses propres variables locales ind√©pendantes
2. **Variables globales** : D√©finies en dehors des fonctions, accessibles partout
3. **Stack frames** : Chaque appel de fonction cr√©e un cadre sur la pile avec ses variables locales
4. **Variables statiques** : Conservent leur valeur entre les appels mais restent locales √† leur fonction
5. **Priorit√© des variables** : Les variables locales ont priorit√© sur les variables globales du m√™me nom
6. **Adresses m√©moire** : Chaque variable a sa propre adresse unique en m√©moire
