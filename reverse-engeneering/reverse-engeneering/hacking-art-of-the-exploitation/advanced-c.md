# Advanced C

## <mark style="color:red;">Segmentation M√©moire</mark>

La m√©moire d'un programme compil√© est divis√©e en cinq segments :&#x20;

* Text
* Data
* Bss
* Heap
* &#x20;Stack.&#x20;

Chaque segment repr√©sente une portion sp√©ciale de la m√©moire qui est r√©serv√©e √† un certain usage.

***

### <mark style="color:blue;">Le Segment Text (Code)</mark>

Le segment text est parfois aussi appel√© **segment de code**.&#x20;

C'est l√† que se trouvent les **instructions en langage machine** assembl√© du programme.&#x20;

L'ex√©cution des instructions dans ce segment est **non lin√©aire**, gr√¢ce aux structures de contr√¥le de haut niveau et aux fonctions mentionn√©es pr√©c√©demment, qui se compilent en instructions de branchement, de saut et d'appel en langage assembleur.

Pendant l'ex√©cution d'un programme, l'EIP est d√©fini sur la premi√®re instruction du segment text. Le processeur suit ensuite une boucle d'ex√©cution qui fait ce qui suit :

1. Lit l'instruction vers laquelle pointe EIP
2. Ajoute la longueur en octets de l'instruction √† EIP
3. Ex√©cute l'instruction qui a √©t√© lue √† l'√©tape 1
4. Retourne √† l'√©tape 1

Parfois l'instruction sera un saut ou un appel, ce qui change l'EIP vers une adresse diff√©rente de la m√©moire.&#x20;

Le processeur ne se soucie pas du changement, car il s'attend de toute fa√ßon √† ce que l'ex√©cution soit non lin√©aire. Si EIP est modifi√© √† l'√©tape 3, le processeur retournera simplement √† l'√©tape 1 et lira l'instruction trouv√©e √† l'adresse de ce que EIP a √©t√© chang√©.

{% hint style="danger" %}
L'autorisation d'√©criture est d√©sactiv√©e dans le segment text, car il n'est pas utilis√© pour stocker des variables, seulement du code.&#x20;
{% endhint %}

Cela emp√™che les gens de modifier r√©ellement le code du programme ; toute tentative d'√©criture dans ce segment de m√©moire fera que le programme alertera l'utilisateur que quelque chose de grave s'est produit, et le programme sera tu√©.&#x20;

‚áí Un autre avantage de ce segment √©tant en lecture seule est qu'il peut √™tre partag√© entre diff√©rentes copies du programme, permettant plusieurs ex√©cutions du programme en m√™me temps sans aucun probl√®me.&#x20;

‚áí Il faut √©galement noter que ce segment de m√©moire a une taille fixe, puisque rien n'y change jamais.

***

### <mark style="color:blue;">Les Segments Data et BSS</mark>

Les segments data et bss sont utilis√©s pour stocker les variables globales et statiques du programme.&#x20;

‚áí Le segment data est rempli avec les variables globales et statiques initialis√©es,

‚áí Le segment bss est rempli avec leurs homologues non initialis√©es.&#x20;

Bien que ces segments soient modifiables, ils ont √©galement une taille fixe. Rappelez-vous que les variables globales persistent, malgr√© le contexte fonctionnel (comme la variable j dans les exemples pr√©c√©dents).&#x20;

Les variables globales et statiques peuvent persister parce qu'elles sont stock√©es dans leurs propres segments de m√©moire.

{% hint style="success" %}
üí° En r√©sum√© : **¬´ taille fixe ¬ª** signifie que la quantit√© de m√©moire r√©serv√©e pour ces variables ne change pas pendant l‚Äôex√©cution, contrairement √† la m√©moire dynamique (heap), qui peut cro√Ætre ou d√©cro√Ætre avec `malloc`/`free`.
{% endhint %}

***

### <mark style="color:blue;">Le Segment Heap (Tas)</mark>

‚áí Le segment heap est un segment de m√©moire qu'un programmeur peut contr√¥ler directement.&#x20;

Des blocs de m√©moire dans ce segment peuvent √™tre allou√©s et utilis√©s pour tout ce dont le programmeur pourrait avoir besoin. Un point notable concernant le segment heap est qu'il n'a pas de taille fixe, donc il peut grandir ou r√©tr√©cir selon les besoins.

&#x20;Toute la m√©moire dans le heap est g√©r√©e par des algorithmes d'allocation et de d√©sallocation, qui respectivement r√©servent une r√©gion de m√©moire dans le heap pour utilisation et suppriment les r√©servations pour permettre √† cette portion de m√©moire d'√™tre r√©utilis√©e pour des r√©servations ult√©rieures.&#x20;

‚áí Le heap grandira et r√©tr√©cira selon la quantit√© de m√©moire r√©serv√©e pour utilisation.&#x20;

Cela signifie qu'un programmeur utilisant les fonctions d'allocation du heap peut r√©server et lib√©rer de la m√©moire √† la vol√©e. La croissance du heap se d√©place vers le bas vers des adresses m√©moire plus √©lev√©es.

***

### <mark style="color:blue;">Le Segment Stack (Pile)</mark>

‚áí Le segment stack a √©galement une taille variable et est utilis√© comme un bloc-notes temporaire pour stocker les variables de fonction locales et le contexte pendant les appels de fonction.&#x20;

C'est ce que regarde la commande backtrace de GDB.&#x20;

* Quand un programme appelle une fonction, cette fonction aura son propre ensemble de variables pass√©es, et le code de la fonction sera √† un emplacement m√©moire diff√©rent dans le segment text (ou code).&#x20;
* Puisque le contexte et l'EIP doivent changer quand une fonction est appel√©e, la pile est utilis√©e pour se souvenir de toutes les variables pass√©es, de l'emplacement o√π l'EIP devrait retourner apr√®s que la fonction soit termin√©e, et de toutes les variables locales utilis√©es par cette fonction. Toutes ces informations sont stock√©es ensemble sur la pile dans ce qu'on appelle collectivement un frame de pile. La pile contient de nombreux frames de pile.

{% hint style="warning" %}
En termes g√©n√©raux d'informatique, une pile est une structure de donn√©es abstraite qui est utilis√©e fr√©quemment. Elle a un ordre premier entr√©, dernier sorti (FILO), ce qui signifie que le premier √©l√©ment qui est mis dans une pile est le dernier √©l√©ment √† en sortir. Pensez-y comme √† enfiler des perles sur un morceau de ficelle qui a un n≈ìud √† une extr√©mit√© - vous ne pouvez pas enlever la premi√®re perle jusqu'√† ce que vous ayez retir√© toutes les autres perles. Quand un √©l√©ment est plac√© dans une pile, c'est connu sous le nom de "push", et quand un √©l√©ment est retir√© d'une pile, c'est appel√© "pop".
{% endhint %}

Comme le nom l'implique, le segment stack de la m√©moire est, en fait, une structure de donn√©es de pile, qui contient des frames de pile.&#x20;

‚áí Le registre ESP est utilis√© pour garder trace de l'adresse de la fin de la pile, qui change constamment alors que des √©l√©ments sont pouss√©s dans et sortis de celle-ci.&#x20;

Puisque c'est un comportement tr√®s dynamique, il est logique que la pile ne soit pas non plus de taille fixe. Contrairement √† la croissance dynamique du heap, alors que la pile change de taille, elle grandit vers le haut dans une liste visuelle de la m√©moire, vers des adresses m√©moire plus basses.

***

### <mark style="color:blue;">Fonctionnement des Frames de Pile</mark>

La nature FILO d'une pile peut sembler √©trange, mais puisque la pile est utilis√©e pour stocker le contexte, elle est tr√®s utile. Quand une fonction est appel√©e, plusieurs choses sont pouss√©es sur la pile ensemble dans un frame de pile.&#x20;

Le registre EBP - parfois appel√© le pointeur de frame (FP) ou pointeur de base locale (LB) - est utilis√© pour r√©f√©rencer les variables de fonction locales dans le frame de pile actuel. Chaque frame de pile contient les param√®tres de la fonction, ses variables locales, et deux pointeurs qui sont n√©cessaires pour remettre les choses comme elles √©taient : le pointeur de frame sauvegard√© (SFP) et l'adresse de retour. Le SFP est utilis√© pour restaurer EBP √† sa valeur pr√©c√©dente, et l'adresse de retour est utilis√©e pour restaurer EIP √† la prochaine instruction trouv√©e apr√®s l'appel de fonction. Cela restaure le contexte fonctionnel du frame de pile pr√©c√©dent.

### Exemple Pratique : stack\_example.c

Le code stack\_example.c suivant a deux fonctions : main() et test\_function().

```c
void test_function(int a, int b, int c, int d) {
    int flag;
    char buffer[10];
    
    flag = 31337;
    buffer[0] = 'A';
}

int main() {
    test_function(1, 2, 3, 4);
}
```

Ce programme d√©clare d'abord une fonction de test qui a quatre arguments, qui sont tous d√©clar√©s comme des entiers : a, b, c, et d. Les variables locales pour la fonction incluent un entier de 4 octets appel√© flag et un tampon de 10 caract√®res appel√© buffer. La m√©moire pour ces variables est dans le segment stack, tandis que les instructions machine pour le code de la fonction sont stock√©es dans le segment text.

### Analyse avec GDB

Apr√®s compilation du programme, son fonctionnement interne peut √™tre examin√© avec GDB. La sortie suivante montre les instructions machine d√©sassembl√©es pour main() et test\_function(). La fonction main() commence √† 0x08048357 et test\_function() commence √† 0x08048344. Les premi√®res instructions de chaque fonction (montr√©es en gras ci-dessous) configurent le frame de pile. Ces instructions sont collectivement appel√©es le prologue de proc√©dure ou prologue de fonction. Elles sauvegardent le pointeur de frame sur la pile, et elles sauvent la m√©moire de pile pour les variables de fonction locales. Parfois le prologue de fonction g√©rera aussi un alignement de pile. Les instructions exactes du prologue varieront grandement selon le compilateur et les options du compilateur, mais en g√©n√©ral ces instructions construisent le frame de pile.

```
reader@hacking:~/booksrc $ gcc -g stack_example.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) disass main
Dump of assembler code for function main():
0x08048357 <main+0>:    push   ebp
0x08048358 <main+1>:    mov    ebp,esp
0x0804835a <main+3>:    sub    esp,0x18
0x0804835d <main+6>:    and    esp,0xfffffff0
0x08048360 <main+9>:    mov    eax,0x0
0x08048365 <main+14>:   sub    esp,eax
0x08048367 <main+16>:   mov    DWORD PTR [esp+12],0x4
0x0804836f <main+24>:   mov    DWORD PTR [esp+8],0x3
0x08048377 <main+32>:   mov    DWORD PTR [esp+4],0x2
0x0804837f <main+40>:   mov    DWORD PTR [esp],0x1
0x08048386 <main+47>:   call   0x8048344 <test_function>
0x0804838b <main+52>:   leave  
0x0804838c <main+53>:   ret    
End of assembler dump

(gdb) disass test_function
Dump of assembler code for function test_function:
0x08048344 <test_function+0>:   push   ebp
0x08048345 <test_function+1>:   mov    ebp,esp
0x08048347 <test_function+3>:   sub    esp,0x28
0x0804834a <test_function+6>:   mov    DWORD PTR [ebp-12],0x7a69
0x08048351 <test_function+13>:  mov    BYTE PTR [ebp-40],0x41
0x08048355 <test_function+17>:  leave  
0x08048356 <test_function+18>:  ret    
End of assembler dump
```

### Construction du Frame de Pile

Quand le programme est ex√©cut√©, la fonction main() est appel√©e, qui appelle simplement test\_function().

Quand test\_function() est appel√©e depuis la fonction main(), les diverses valeurs sont pouss√©es sur la pile pour cr√©er le d√©but du frame de pile comme suit. Quand test\_function() est appel√©e, les arguments de la fonction sont pouss√©s sur la pile dans l'ordre inverse (puisque c'est FILO). Les arguments pour la fonction sont 1, 2, 3, et 4, donc les instructions push subs√©quentes poussent 4, 3, 2, et finalement 1 sur la pile. Ces valeurs correspondent aux variables d, c, b, et a dans la fonction. Les instructions qui mettent ces valeurs sur la pile sont montr√©es en gras dans le d√©sassemblage de la fonction main() ci-dessus.

Ensuite, quand l'instruction d'assemblage call est ex√©cut√©e, l'adresse de retour est pouss√©e sur la pile et le flux d'ex√©cution saute au d√©but de test\_function() √† 0x08048344. La valeur de l'adresse de retour sera l'emplacement de l'instruction suivant l'EIP actuel - sp√©cifiquement, la valeur stock√©e pendant l'√©tape 3 de la boucle d'ex√©cution mentionn√©e pr√©c√©demment. Dans ce cas, l'adresse de retour pointerait vers l'instruction leave dans main() √† 0x0804838b.

L'instruction call stocke √† la fois l'adresse de retour sur la pile et fait sauter l'EIP au d√©but de test\_function(), donc les instructions du prologue de proc√©dure de test\_function() finissent de construire le frame de pile. Dans cette √©tape, la valeur actuelle d'EBP est pouss√©e sur la pile. Cette valeur est appel√©e le pointeur de frame sauvegard√© (SFP) et est utilis√©e plus tard pour restaurer EBP √† son √©tat original. La valeur actuelle d'ESP est ensuite copi√©e dans EBP pour d√©finir le nouveau pointeur de frame. Ce pointeur de frame est utilis√© pour r√©f√©rencer les variables locales de la fonction (flag et buffer). La m√©moire est sauv√©e pour ces variables en soustrayant d'ESP.

### Structure Finale du Frame de Pile

√Ä la fin, le frame de pile ressemble √† quelque chose comme ceci :

```
buffer
flag
Pointeur de frame sauvegard√© (SFP)
Adresse de retour (ret)
a
b
c
d
                    ‚Üê Haut de la pile
                    ‚Üê Pointeur de frame (EBP)
Adresses basses
Adresses hautes
```

### Observation avec GDB

Nous pouvons observer la construction du frame de pile sur la pile en utilisant GDB. Dans la sortie suivante, un point d'arr√™t est d√©fini dans main() avant l'appel √† test\_function() et aussi au d√©but de test\_function(). GDB mettra le premier point d'arr√™t avant que les arguments de fonction soient pouss√©s sur la pile, et le second point d'arr√™t apr√®s le prologue de proc√©dure de test\_function(). Quand le programme est ex√©cut√©, l'ex√©cution s'arr√™te au point d'arr√™t, o√π les registres ESP (pointeur de pile), EBP (pointeur de frame), et EIP (pointeur d'ex√©cution) sont examin√©s.

```
(gdb) list main
4
5    flag = 31337;
6    buffer[0] = 'A';
7 }
8
9 int main() {
10    test_function(1, 2, 3, 4);
11 }
(gdb) break 10
Breakpoint 1 at 0x8048367: file stack_example.c, line 10.
(gdb) break test_function
Breakpoint 2 at 0x804834a: file stack_example.c, line 5.
(gdb) run
Starting program: /home/reader/booksrc/a.out

Breakpoint 1, main () at stack_example.c:10
10        test_function(1, 2, 3, 4);
(gdb) i r esp ebp eip
esp            0xbffff7f0       0xbffff7f0
ebp            0xbffff808       0xbffff808
eip            0x8048367        0x8048367 <main+16>
(gdb) x/5i $eip
0x8048367 <main+16>:    mov    DWORD PTR [esp+12],0x4
0x804836f <main+24>:    mov    DWORD PTR [esp+8],0x3
0x8048377 <main+32>:    mov    DWORD PTR [esp+4],0x2
0x804837f <main+40>:    mov    DWORD PTR [esp],0x1
0x8048386 <main+47>:    call   0x8048344 <test_function>
```

Ce point d'arr√™t est juste avant que le frame de pile pour l'appel test\_function() soit cr√©√©. Cela signifie que le bas de ce nouveau frame de pile est √† la valeur actuelle d'ESP, 0xbffff7f0. Le prochain point d'arr√™t est juste apr√®s le prologue de proc√©dure pour test\_function(), donc continuer construira le frame de pile. La sortie ci-dessous montre des informations similaires au second point d'arr√™t. Les variables locales (flag et buffer) sont r√©f√©renc√©es relativement au pointeur de frame (EBP).

```
(gdb) cont
Continuing.

Breakpoint 2, test_function (a=1, b=2, c=3, d=4) at stack_example.c:5
5        flag = 31337;
(gdb) i r esp ebp eip
esp            0xbffff7c0       0xbffff7c0
ebp            0xbffff7e8       0xbffff7e8
eip            0x804834a        0x804834a <test_function+6>
(gdb) disass test_function
Dump of assembler code for function test_function:
0x08048344 <test_function+0>:   push   ebp
0x08048345 <test_function+1>:   mov    ebp,esp
0x08048347 <test_function+3>:   sub    esp,0x28
0x0804834a <test_function+6>:   mov    DWORD PTR [ebp-12],0x7a69
0x08048351 <test_function+13>:  mov    BYTE PTR [ebp-40],0x41
0x08048355 <test_function+17>:  leave  
0x08048356 <test_function+18>:  ret    
End of assembler dump.
(gdb) print $ebp-12
$1 = (void *) 0xbffff7dc
(gdb) print $ebp-40
$2 = (void *) 0xbffff7c0
(gdb) x/16xw $esp
0xbffff7c0: 0x00000000      0x08049548      0xbffff7d8      0x08048249
0xbffff7d0: 0xb7f9f729      0xb7fd6ff4      0xbffff808      0x080483b9
0xbffff7e0: 0xb7fd6ff4      0xbffff89c      0xbffff808      0x0804838b
0xbffff7f0: 0x00000001      0x00000002      0x00000003      0x00000004
```

Le frame de pile est montr√© sur la pile √† la fin. Les quatre arguments √† la fonction peuvent √™tre vus au bas du frame de pile (‚ë†), avec l'adresse de retour trouv√©e directement au-dessus (‚ë°). Au-dessus de cela se trouve le pointeur de frame sauvegard√© de 0xbffff808 (‚ë¢), qui est ce qu'√©tait EBP dans le frame de pile pr√©c√©dent. Le reste de la m√©moire est sauv√© pour les variables de pile locales : flag et buffer. Calculer leurs adresses relatives √† EBP montre leurs emplacements exacts dans le frame de pile. La m√©moire pour la variable flag est montr√©e √† (‚ë£) et la m√©moire pour la variable buffer est montr√©e √† (‚ë§). L'espace suppl√©mentaire dans le frame de pile est juste du remplissage.

### Fin d'Ex√©cution et Nettoyage

Apr√®s que l'ex√©cution se termine, l'entier frame de pile est sorti de la pile, et l'EIP est d√©fini √† l'adresse de retour pour que le programme puisse continuer l'ex√©cution. Si une autre fonction √©tait appel√©e dans la fonction, un autre frame de pile serait pouss√© sur la pile, et ainsi de suite. Comme chaque fonction se termine, son frame de pile est sorti de la pile pour que l'ex√©cution puisse √™tre retourn√©e √† la fonction pr√©c√©dente. Ce comportement est la raison pour laquelle ce segment de m√©moire est organis√© dans une structure de donn√©es FILO.

### Organisation des Segments M√©moire

Les divers segments de m√©moire sont arrang√©s dans l'ordre dans lequel ils ont √©t√© pr√©sent√©s, des adresses m√©moire les plus basses aux adresses m√©moire les plus hautes. Puisque la plupart des gens sont familiers avec voir des listes num√©rot√©es qui comptent vers le bas, les plus petites adresses m√©moire sont montr√©es au sommet. Certains textes ont ceci invers√©, ce qui peut √™tre tr√®s confusant ; donc pour ce cours...
