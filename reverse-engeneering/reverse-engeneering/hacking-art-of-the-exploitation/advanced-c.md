# Advanced C

## <mark style="color:red;">Segmentation Mémoire</mark>

La mémoire d'un programme compilé est divisée en cinq segments :&#x20;

* Text
* Data
* Bss
* Heap
* &#x20;Stack.&#x20;

Chaque segment représente une portion spéciale de la mémoire qui est réservée à un certain usage.

***

### <mark style="color:blue;">Le Segment Text (Code)</mark>

Le segment text est parfois aussi appelé **segment de code**.&#x20;

C'est là que se trouvent les **instructions en langage machine** assemblé du programme.&#x20;

L'exécution des instructions dans ce segment est **non linéaire**, grâce aux structures de contrôle de haut niveau et aux fonctions mentionnées précédemment, qui se compilent en instructions de branchement, de saut et d'appel en langage assembleur.

Pendant l'exécution d'un programme, l'EIP est défini sur la première instruction du segment text. Le processeur suit ensuite une boucle d'exécution qui fait ce qui suit :

1. Lit l'instruction vers laquelle pointe EIP
2. Ajoute la longueur en octets de l'instruction à EIP
3. Exécute l'instruction qui a été lue à l'étape 1
4. Retourne à l'étape 1

Parfois l'instruction sera un saut ou un appel, ce qui change l'EIP vers une adresse différente de la mémoire. Le processeur ne se soucie pas du changement, car il s'attend de toute façon à ce que l'exécution soit non linéaire. Si EIP est modifié à l'étape 3, le processeur retournera simplement à l'étape 1 et lira l'instruction trouvée à l'adresse de ce que EIP a été changé.

{% hint style="danger" %}
L'autorisation d'écriture est désactivée dans le segment text, car il n'est pas utilisé pour stocker des variables, seulement du code.&#x20;
{% endhint %}

Cela empêche les gens de modifier réellement le code du programme ; toute tentative d'écriture dans ce segment de mémoire fera que le programme alertera l'utilisateur que quelque chose de grave s'est produit, et le programme sera tué.&#x20;

⇒ Un autre avantage de ce segment étant en lecture seule est qu'il peut être partagé entre différentes copies du programme, permettant plusieurs exécutions du programme en même temps sans aucun problème.&#x20;

⇒ Il faut également noter que ce segment de mémoire a une taille fixe, puisque rien n'y change jamais.

***

### <mark style="color:blue;">Les Segments Data et BSS</mark>

Les segments data et bss sont utilisés pour stocker les variables globales et statiques du programme.&#x20;

⇒ Le segment data est rempli avec les variables globales et statiques initialisées,

⇒ Le segment bss est rempli avec leurs homologues non initialisées. Bien que ces segments soient modifiables, ils ont également une taille fixe. Rappelez-vous que les variables globales persistent, malgré le contexte fonctionnel (comme la variable j dans les exemples précédents). Les variables globales et statiques peuvent persister parce qu'elles sont stockées dans leurs propres segments de mémoire.

### Le Segment Heap (Tas)

Le segment heap est un segment de mémoire qu'un programmeur peut contrôler directement. Des blocs de mémoire dans ce segment peuvent être alloués et utilisés pour tout ce dont le programmeur pourrait avoir besoin. Un point notable concernant le segment heap est qu'il n'a pas de taille fixe, donc il peut grandir ou rétrécir selon les besoins. Toute la mémoire dans le heap est gérée par des algorithmes d'allocation et de désallocation, qui respectivement réservent une région de mémoire dans le heap pour utilisation et suppriment les réservations pour permettre à cette portion de mémoire d'être réutilisée pour des réservations ultérieures. Le heap grandira et rétrécira selon la quantité de mémoire réservée pour utilisation. Cela signifie qu'un programmeur utilisant les fonctions d'allocation du heap peut réserver et libérer de la mémoire à la volée. La croissance du heap se déplace vers le bas vers des adresses mémoire plus élevées.

### Le Segment Stack (Pile)

Le segment stack a également une taille variable et est utilisé comme un bloc-notes temporaire pour stocker les variables de fonction locales et le contexte pendant les appels de fonction. C'est ce que regarde la commande backtrace de GDB. Quand un programme appelle une fonction, cette fonction aura son propre ensemble de variables passées, et le code de la fonction sera à un emplacement mémoire différent dans le segment text (ou code). Puisque le contexte et l'EIP doivent changer quand une fonction est appelée, la pile est utilisée pour se souvenir de toutes les variables passées, de l'emplacement où l'EIP devrait retourner après que la fonction soit terminée, et de toutes les variables locales utilisées par cette fonction. Toutes ces informations sont stockées ensemble sur la pile dans ce qu'on appelle collectivement un frame de pile. La pile contient de nombreux frames de pile.

En termes généraux d'informatique, une pile est une structure de données abstraite qui est utilisée fréquemment. Elle a un ordre premier entré, dernier sorti (FILO), ce qui signifie que le premier élément qui est mis dans une pile est le dernier élément à en sortir. Pensez-y comme à enfiler des perles sur un morceau de ficelle qui a un nœud à une extrémité - vous ne pouvez pas enlever la première perle jusqu'à ce que vous ayez retiré toutes les autres perles. Quand un élément est placé dans une pile, c'est connu sous le nom de "push", et quand un élément est retiré d'une pile, c'est appelé "pop".

Comme le nom l'implique, le segment stack de la mémoire est, en fait, une structure de données de pile, qui contient des frames de pile. Le registre ESP est utilisé pour garder trace de l'adresse de la fin de la pile, qui change constamment alors que des éléments sont poussés dans et sortis de celle-ci. Puisque c'est un comportement très dynamique, il est logique que la pile ne soit pas non plus de taille fixe. Contrairement à la croissance dynamique du heap, alors que la pile change de taille, elle grandit vers le haut dans une liste visuelle de la mémoire, vers des adresses mémoire plus basses.

### Fonctionnement des Frames de Pile

La nature FILO d'une pile peut sembler étrange, mais puisque la pile est utilisée pour stocker le contexte, elle est très utile. Quand une fonction est appelée, plusieurs choses sont poussées sur la pile ensemble dans un frame de pile. Le registre EBP - parfois appelé le pointeur de frame (FP) ou pointeur de base locale (LB) - est utilisé pour référencer les variables de fonction locales dans le frame de pile actuel. Chaque frame de pile contient les paramètres de la fonction, ses variables locales, et deux pointeurs qui sont nécessaires pour remettre les choses comme elles étaient : le pointeur de frame sauvegardé (SFP) et l'adresse de retour. Le SFP est utilisé pour restaurer EBP à sa valeur précédente, et l'adresse de retour est utilisée pour restaurer EIP à la prochaine instruction trouvée après l'appel de fonction. Cela restaure le contexte fonctionnel du frame de pile précédent.

### Exemple Pratique : stack\_example.c

Le code stack\_example.c suivant a deux fonctions : main() et test\_function().

```c
void test_function(int a, int b, int c, int d) {
    int flag;
    char buffer[10];
    
    flag = 31337;
    buffer[0] = 'A';
}

int main() {
    test_function(1, 2, 3, 4);
}
```

Ce programme déclare d'abord une fonction de test qui a quatre arguments, qui sont tous déclarés comme des entiers : a, b, c, et d. Les variables locales pour la fonction incluent un entier de 4 octets appelé flag et un tampon de 10 caractères appelé buffer. La mémoire pour ces variables est dans le segment stack, tandis que les instructions machine pour le code de la fonction sont stockées dans le segment text.

### Analyse avec GDB

Après compilation du programme, son fonctionnement interne peut être examiné avec GDB. La sortie suivante montre les instructions machine désassemblées pour main() et test\_function(). La fonction main() commence à 0x08048357 et test\_function() commence à 0x08048344. Les premières instructions de chaque fonction (montrées en gras ci-dessous) configurent le frame de pile. Ces instructions sont collectivement appelées le prologue de procédure ou prologue de fonction. Elles sauvegardent le pointeur de frame sur la pile, et elles sauvent la mémoire de pile pour les variables de fonction locales. Parfois le prologue de fonction gérera aussi un alignement de pile. Les instructions exactes du prologue varieront grandement selon le compilateur et les options du compilateur, mais en général ces instructions construisent le frame de pile.

```
reader@hacking:~/booksrc $ gcc -g stack_example.c
reader@hacking:~/booksrc $ gdb -q ./a.out
Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".
(gdb) disass main
Dump of assembler code for function main():
0x08048357 <main+0>:    push   ebp
0x08048358 <main+1>:    mov    ebp,esp
0x0804835a <main+3>:    sub    esp,0x18
0x0804835d <main+6>:    and    esp,0xfffffff0
0x08048360 <main+9>:    mov    eax,0x0
0x08048365 <main+14>:   sub    esp,eax
0x08048367 <main+16>:   mov    DWORD PTR [esp+12],0x4
0x0804836f <main+24>:   mov    DWORD PTR [esp+8],0x3
0x08048377 <main+32>:   mov    DWORD PTR [esp+4],0x2
0x0804837f <main+40>:   mov    DWORD PTR [esp],0x1
0x08048386 <main+47>:   call   0x8048344 <test_function>
0x0804838b <main+52>:   leave  
0x0804838c <main+53>:   ret    
End of assembler dump

(gdb) disass test_function
Dump of assembler code for function test_function:
0x08048344 <test_function+0>:   push   ebp
0x08048345 <test_function+1>:   mov    ebp,esp
0x08048347 <test_function+3>:   sub    esp,0x28
0x0804834a <test_function+6>:   mov    DWORD PTR [ebp-12],0x7a69
0x08048351 <test_function+13>:  mov    BYTE PTR [ebp-40],0x41
0x08048355 <test_function+17>:  leave  
0x08048356 <test_function+18>:  ret    
End of assembler dump
```

### Construction du Frame de Pile

Quand le programme est exécuté, la fonction main() est appelée, qui appelle simplement test\_function().

Quand test\_function() est appelée depuis la fonction main(), les diverses valeurs sont poussées sur la pile pour créer le début du frame de pile comme suit. Quand test\_function() est appelée, les arguments de la fonction sont poussés sur la pile dans l'ordre inverse (puisque c'est FILO). Les arguments pour la fonction sont 1, 2, 3, et 4, donc les instructions push subséquentes poussent 4, 3, 2, et finalement 1 sur la pile. Ces valeurs correspondent aux variables d, c, b, et a dans la fonction. Les instructions qui mettent ces valeurs sur la pile sont montrées en gras dans le désassemblage de la fonction main() ci-dessus.

Ensuite, quand l'instruction d'assemblage call est exécutée, l'adresse de retour est poussée sur la pile et le flux d'exécution saute au début de test\_function() à 0x08048344. La valeur de l'adresse de retour sera l'emplacement de l'instruction suivant l'EIP actuel - spécifiquement, la valeur stockée pendant l'étape 3 de la boucle d'exécution mentionnée précédemment. Dans ce cas, l'adresse de retour pointerait vers l'instruction leave dans main() à 0x0804838b.

L'instruction call stocke à la fois l'adresse de retour sur la pile et fait sauter l'EIP au début de test\_function(), donc les instructions du prologue de procédure de test\_function() finissent de construire le frame de pile. Dans cette étape, la valeur actuelle d'EBP est poussée sur la pile. Cette valeur est appelée le pointeur de frame sauvegardé (SFP) et est utilisée plus tard pour restaurer EBP à son état original. La valeur actuelle d'ESP est ensuite copiée dans EBP pour définir le nouveau pointeur de frame. Ce pointeur de frame est utilisé pour référencer les variables locales de la fonction (flag et buffer). La mémoire est sauvée pour ces variables en soustrayant d'ESP.

### Structure Finale du Frame de Pile

À la fin, le frame de pile ressemble à quelque chose comme ceci :

```
buffer
flag
Pointeur de frame sauvegardé (SFP)
Adresse de retour (ret)
a
b
c
d
                    ← Haut de la pile
                    ← Pointeur de frame (EBP)
Adresses basses
Adresses hautes
```

### Observation avec GDB

Nous pouvons observer la construction du frame de pile sur la pile en utilisant GDB. Dans la sortie suivante, un point d'arrêt est défini dans main() avant l'appel à test\_function() et aussi au début de test\_function(). GDB mettra le premier point d'arrêt avant que les arguments de fonction soient poussés sur la pile, et le second point d'arrêt après le prologue de procédure de test\_function(). Quand le programme est exécuté, l'exécution s'arrête au point d'arrêt, où les registres ESP (pointeur de pile), EBP (pointeur de frame), et EIP (pointeur d'exécution) sont examinés.

```
(gdb) list main
4
5    flag = 31337;
6    buffer[0] = 'A';
7 }
8
9 int main() {
10    test_function(1, 2, 3, 4);
11 }
(gdb) break 10
Breakpoint 1 at 0x8048367: file stack_example.c, line 10.
(gdb) break test_function
Breakpoint 2 at 0x804834a: file stack_example.c, line 5.
(gdb) run
Starting program: /home/reader/booksrc/a.out

Breakpoint 1, main () at stack_example.c:10
10        test_function(1, 2, 3, 4);
(gdb) i r esp ebp eip
esp            0xbffff7f0       0xbffff7f0
ebp            0xbffff808       0xbffff808
eip            0x8048367        0x8048367 <main+16>
(gdb) x/5i $eip
0x8048367 <main+16>:    mov    DWORD PTR [esp+12],0x4
0x804836f <main+24>:    mov    DWORD PTR [esp+8],0x3
0x8048377 <main+32>:    mov    DWORD PTR [esp+4],0x2
0x804837f <main+40>:    mov    DWORD PTR [esp],0x1
0x8048386 <main+47>:    call   0x8048344 <test_function>
```

Ce point d'arrêt est juste avant que le frame de pile pour l'appel test\_function() soit créé. Cela signifie que le bas de ce nouveau frame de pile est à la valeur actuelle d'ESP, 0xbffff7f0. Le prochain point d'arrêt est juste après le prologue de procédure pour test\_function(), donc continuer construira le frame de pile. La sortie ci-dessous montre des informations similaires au second point d'arrêt. Les variables locales (flag et buffer) sont référencées relativement au pointeur de frame (EBP).

```
(gdb) cont
Continuing.

Breakpoint 2, test_function (a=1, b=2, c=3, d=4) at stack_example.c:5
5        flag = 31337;
(gdb) i r esp ebp eip
esp            0xbffff7c0       0xbffff7c0
ebp            0xbffff7e8       0xbffff7e8
eip            0x804834a        0x804834a <test_function+6>
(gdb) disass test_function
Dump of assembler code for function test_function:
0x08048344 <test_function+0>:   push   ebp
0x08048345 <test_function+1>:   mov    ebp,esp
0x08048347 <test_function+3>:   sub    esp,0x28
0x0804834a <test_function+6>:   mov    DWORD PTR [ebp-12],0x7a69
0x08048351 <test_function+13>:  mov    BYTE PTR [ebp-40],0x41
0x08048355 <test_function+17>:  leave  
0x08048356 <test_function+18>:  ret    
End of assembler dump.
(gdb) print $ebp-12
$1 = (void *) 0xbffff7dc
(gdb) print $ebp-40
$2 = (void *) 0xbffff7c0
(gdb) x/16xw $esp
0xbffff7c0: 0x00000000      0x08049548      0xbffff7d8      0x08048249
0xbffff7d0: 0xb7f9f729      0xb7fd6ff4      0xbffff808      0x080483b9
0xbffff7e0: 0xb7fd6ff4      0xbffff89c      0xbffff808      0x0804838b
0xbffff7f0: 0x00000001      0x00000002      0x00000003      0x00000004
```

Le frame de pile est montré sur la pile à la fin. Les quatre arguments à la fonction peuvent être vus au bas du frame de pile (①), avec l'adresse de retour trouvée directement au-dessus (②). Au-dessus de cela se trouve le pointeur de frame sauvegardé de 0xbffff808 (③), qui est ce qu'était EBP dans le frame de pile précédent. Le reste de la mémoire est sauvé pour les variables de pile locales : flag et buffer. Calculer leurs adresses relatives à EBP montre leurs emplacements exacts dans le frame de pile. La mémoire pour la variable flag est montrée à (④) et la mémoire pour la variable buffer est montrée à (⑤). L'espace supplémentaire dans le frame de pile est juste du remplissage.

### Fin d'Exécution et Nettoyage

Après que l'exécution se termine, l'entier frame de pile est sorti de la pile, et l'EIP est défini à l'adresse de retour pour que le programme puisse continuer l'exécution. Si une autre fonction était appelée dans la fonction, un autre frame de pile serait poussé sur la pile, et ainsi de suite. Comme chaque fonction se termine, son frame de pile est sorti de la pile pour que l'exécution puisse être retournée à la fonction précédente. Ce comportement est la raison pour laquelle ce segment de mémoire est organisé dans une structure de données FILO.

### Organisation des Segments Mémoire

Les divers segments de mémoire sont arrangés dans l'ordre dans lequel ils ont été présentés, des adresses mémoire les plus basses aux adresses mémoire les plus hautes. Puisque la plupart des gens sont familiers avec voir des listes numérotées qui comptent vers le bas, les plus petites adresses mémoire sont montrées au sommet. Certains textes ont ceci inversé, ce qui peut être très confusant ; donc pour ce cours...
